[{"title":"MarkDown学习","url":"/2025/05/12/knows/MarkDown%E5%AD%A6%E4%B9%A0/","content":"标题学习# 一级标题## 二级标题### 三级标题\n\n列表学习- 无序列表- 无序列表- 无序列表\n\n1. 有序列表2. 有序列表3. 有序列表\n\n引用学习&gt; 引用学习\n\n分割线学习---\n\n图片学习![图片名称](图片路径)\n\n超链接学习[超链接名称](超链接路径)或者 跳转到新的窗口[超链接名称](超链接路径 &quot;新窗口&quot;)&#123;target=&quot;_blank&quot;&#125;### 代码学习\n\n代码内容\n\n表格学习要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。\n| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text |\n\n\n\n\nSyntax\nDescription\n\n\n\nHeader\nTitle\n\n\nParagraph\nText\n\n\n","categories":["知识库"]},{"title":"正则表达式","url":"/2025/05/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"正则表达式基础[^&gt;]表示什么？🔍 [] 在正则表达式中的含义：字符类（Character Class）[] 表示字符类，用来定义一组可匹配的字符。\n基本语法：[abc]     // 匹配 a 或 b 或 c 中的任意一个字符[a-z]     // 匹配 a 到 z 的任意小写字母[0-9]     // 匹配 0 到 9 的任意数字[A-Za-z]  // 匹配任意大小写字母\n\n否定字符类：[^abc]    // 匹配除了 a、b、c 之外的任何字符[^0-9]    // 匹配非数字字符[^&gt;]      // 匹配除了 &gt; 之外的任何字符\n\n在你的例子中：[^&gt;]*\n\n分解：\n\n[^&gt;] - 字符类：匹配除了 &gt; 之外的任意一个字符\n* - 量词：表示前面的字符类可以出现 0 次或多次\n\n实际匹配示例：&lt;!-- 原始HTML --&gt;&lt;title data-rh=&quot;true&quot; class=&quot;page-title&quot;&gt;我的标题 - 知乎&lt;/title&gt;&lt;!-- 正则匹配过程 --&gt;&lt;title ← 匹配字面量 [^&gt;\t]* ← 匹配 &quot; data-rh=\\&quot;true\\&quot; class=\\&quot;page-title\\&quot;&quot; &gt; ← 匹配标签结束符 (.*?)\t← 捕获 &quot;我的标题&quot; - 知乎&lt;/title&gt;← 匹配结尾\n\n其他字符类例子：RegExp(r&#x27;[aeiou]&#x27;)     // 匹配元音字母RegExp(r&#x27;[^aeiou]&#x27;)    // 匹配非元音字母RegExp(r&#x27;[0-9]+&#x27;)      // 匹配一个或多个数字RegExp(r&#x27;[a-zA-Z_]&#x27;)   // 匹配字母或下划线RegExp(r&#x27;[^a-zA-Z0-9]&#x27;) // 匹配非字母数字字符\n\n总结：[] 就是用来定义一组字符选择的容器！\n","categories":["知识库"]},{"title":"禅的世界-圣严法师","url":"/2025/05/12/books/%E4%BD%9B%E5%AD%A6/%E7%A6%85%E7%9A%84%E4%B8%96%E7%95%8C/","content":"禅的世界-圣严法师\n释圣严，或尊称为圣严“法师”（1931年1月22日－2009年2月3日），俗名张保康，江苏南通人，佛学“大师”，教育家，佛教“弘法大师”，日本立正大学博士，也是禅宗曹洞宗的第五十代传人、临济宗的第五十七代传人、台湾法鼓山的创办人，法鼓山的弟子信众尊称为“师父”。\n\n禪的世界 - 聖嚴法師.pdf (访问密码: 5098)\n","categories":["佛学"]},{"title":"字里藏医","url":"/2025/05/13/books/zhongyi/%E5%AD%97%E9%87%8C%E8%97%8F%E5%8C%BB/","content":"\n《字里藏医》是2007年安徽教育出版社出版的图书，作者是徐文兵。该书深入浅出地介绍了中医词汇的古今之别，以帮助读者了解中医的基本知识。\n\n内容简介几千年来，我们使用的都是同样的文字，但表达的意思可能已经不同了。很多字词已经渐渐失去了它们的原意。在多数情况下，这并不会造成什么困扰，但对中医这门古老学问就不同了，它需要我们唤醒那些沉睡的文字的原意。在现代语境下，在涉外教学看病过程中，徐文兵大夫随时会遭遇熟悉字词的陌生化情形。比如说“思想”，思和想有什么区别？又比如“魂魄”，魂是什么，魄是什么？“肥”与“胖”的区别？“皮”与“肤”是一回事吗？    要研究中医，发皇古意，就必须先从最基本的词汇入手，正义严辞。《字里藏医》就是这样一本以深入浅出的文字厘清中医最基本的词汇，恢复中医本来面目的启蒙书。\n下载地址字里藏医.txt (访问密码: 5098)\n","categories":["中医"],"tags":["徐文兵"]},{"title":"什么是AIGC","url":"/2025/09/22/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AFaigc/","content":"AIGC（Artificial Intelligence Generated Content，人工智能生成内容）是继 PGC（专业生产内容）和 UGC（用户生产内容）之后的第三代内容创作范式，通过 AI 算法自动生成文本、图像、音频、视频、3D 模型等多模态内容。其核心在于利用生成对抗网络（GAN）、扩散模型（Diffusion）、大语言模型（LLM）等技术，从数据中学习规律并创造新内容。以下从技术原理、应用场景、争议挑战及未来发展四个维度综合分析：\n\n⚙️ 一、技术原理与核心组件\n生成模型架构\nGAN（生成对抗网络）：通过生成器与判别器的对抗训练生成逼真内容（如图像、音频）。\n扩散模型：从噪声逐步重构数据，生成高质量内容（如 Stable Diffusion、DALL·E）。\nTransformer 与大语言模型（LLM）：基于预训练模型（如 GPT 系列）实现文本创作、代码生成等任务。\n\n\n多模态与跨模态技术\n整合文本、图像、视频等多类型数据，实现跨模态生成（如文生图、文生视频）。\nRAG（检索增强生成）：结合信息检索与生成模型，提升内容准确性与深度。\n\n\n\n\n🌐 二、应用场景与行业变革\n\n\n领域\n典型应用\n案例&#x2F;工具\n\n\n\n内容创作\n自动生成新闻稿、营销文案、短视频脚本\nChatGPT、通义千问\n\n\n设计娱乐\nAI 绘画、3D 建模、游戏角色生成、影视特效\nMidjourney、Sora、Unity AIGC 工具\n\n\n教育医疗\n个性化学习材料生成、医学影像分析报告\nAI 虚拟教师、医疗知识图谱\n\n\n工业与科研\n集成电路设计优化、科研文献摘要生成\nPRIME 深度学习框架\n\n\n数字人服务\n虚拟主播、AI 客服、康养监测（如跌倒报警）\n广州虚拟动力 3D 数字人\n\n\n\n突破性价值：\n\n效率提升：10 分钟生成 1000 条广告文案，成本降低 90%；\n创新赋能：设计师用 AI 生成基础方案，聚焦创意优化。\n\n\n\n️ 三、争议与挑战\n内容真实性风险\n虚假信息泛滥：深度伪造技术生成虚假新闻、视频，扰乱舆论。\n学术伦理争议：多所高校引入 AIGC 查重系统（如四川大学要求 AIGC 率＜ 20%），但手写内容常被误判为 AI 生成。\n\n\n技术局限性\n逻辑缺陷：依赖概率统计生成内容，缺乏因果推理能力（如医疗诊断可能出错）。\n版权归属模糊：AI 生成作品版权界定不清，法律监管滞后。\n\n\n社会影响\n信息过载：低质同质化内容淹没优质信息，用户筛选成本增加。\n就业冲击：部分创意岗位可能被替代（如基础文案、插画师）。\n\n\n\n\n🚀 四、未来发展方向\n技术融合创新\n语义通信（SemCom）：提升无线网络中的 AIGC 传输效率，降低延迟。\n边缘计算部署：在移动端部署轻量化模型（如手机实时生成 3D 内容）。\n\n\n治理与标准化\n中国推行《AIGC 内容标识办法》，要求平台标注“AI 生成合成”标识；\n欧盟《AI 法案》建立伦理框架，规范深度伪造使用。\n\n\n人机协同范式\n认知套利模式：人类聚焦场景化转译与价值审核，AI 负责批量生产；\n教育适配：高校课程融入 AIGC 工具教学（如提示词工程），培养“AI+专业”复合能力。\n\n\n\n\n💎 总结：颠覆性潜力与理性应对AIGC 的本质是生产力工具的革命，其核心价值在于释放人类创造力而非替代人类。当前需平衡三组关系：\n\n效率与质量：利用 AI 提升内容产出规模，同时建立人工审核机制保障深度；\n开放与治理：鼓励技术开源（如 ComfyUI 社区），同步完善法律与伦理规范；\n工具与主体：避免陷入“技术万能”误区，明确“人类决策+AI 执行”的协作边界。\n\n\n行动建议：\n\n开发者：深耕多模态模型优化与垂直场景落地（如工业设计、医疗影像）；\n普通用户：掌握提示词设计、跨工具工作流整合（如 Midjourney+PS 后期）；\n政策制定者：加速数据安全立法，建立 AIGC 内容溯源机制。\n\n\n","categories":["知识库"],"tags":["ai","大模型","AIGC"]},{"title":"什么是数据集","url":"/2025/07/31/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"什么是数据集“数据集”可以简单理解为为了完成某个机器学习任务而收集在一起的样本集合。对图像分类任务来说，常见的数据集至少包含两大核心部分：\n1、样本（samples）\n图片文件（JPG&#x2F;PNG&#x2F;TIFF&#x2F;…）。有时附带文本、视频、传感器数据等。\n2、标签（labels &#x2F; annotations）\n单标签：一张图对应一个类别，如 downward_dog。多标签：一张图可对应多个标签。框级 &#x2F; 像素级：目标检测、语义分割会给出边界框或掩码（COCO JSON、Pascal VOC XML、PNG mask）。\n","categories":["知识库"],"tags":["ai","大模型","数据集"]},{"title":"什么是训练和推理","url":"/2025/07/24/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86/","content":"什么是训练和推理\n\n\n项目\n含义\n场景\n\n\n\n模型训练（Training）：\n让 AI 学习数据中的规律，调整参数\n需要大量计算资源，一般在电脑或云端完成\n\n\n模型推理（Inference）\n使用训练好的模型对新数据做出预测\n可以部署到手机、平板、IoT 设备等\n\n\npython 训练示例import tensorflow as tf# 加载预训练模型（不需要自己训练）model = tf.keras.applications.MobileNetV2(weights=&#x27;imagenet&#x27;)# 将模型转为 TFLite 格式converter = tf.lite.TFLiteConverter.from_keras_model(model)tflite_model = converter.convert()# 保存为 .tflite 文件with open(&#x27;mobilenet_v2.tflite&#x27;, &#x27;wb&#x27;) as f:    f.write(tflite_model)\n\npython 推理示例注： 要先下载 labels.txt （1000 条记录）\nimport numpy as npfrom PIL import Imageimport tensorflow as tf# 加载 TFLite 模型interpreter = tf.lite.Interpreter(model_path=&quot;mobilenet_v2.tflite&quot;)interpreter.allocate_tensors()# 获取输入输出信息input_details = interpreter.get_input_details()output_details = interpreter.get_output_details()# 准备图片数据def load_image(image_path):    img = Image.open(image_path).convert(&#x27;RGB&#x27;)    img = img.resize((224, 224))    img_array = np.array(img, dtype=np.float32) / 255.0    return np.expand_dims(img_array, axis=0)# 加载并预处理图像image_data = load_image(&quot;test2.jpg&quot;)# 设置输入张量interpreter.set_tensor(input_details[0][&#x27;index&#x27;], image_data)# 运行推理interpreter.invoke()# 获取输出结果output_data = interpreter.get_tensor(output_details[0][&#x27;index&#x27;])# 读取标签文件with open(&quot;labels.txt&quot;, &quot;r&quot;) as f:    labels = [line.strip() for line in f.readlines()]# 打印置信度最高的前 5 个结果top_k = 5top_indices = np.argsort(output_data)[0][-top_k:][::-1]  # 降序排列for i, idx in enumerate(top_indices):    label = labels[idx]    confidence = output_data[0][idx]    print(f&quot;&#123;i+1&#125;. &#123;label&#125;: &#123;confidence:.4f&#125;&quot;)\n\n输出\n\ncurly-coated retriever: 0.8806\nNewfoundland, Newfoundland dog: 0.0108\ngolden retriever: 0.0081\ncocker spaniel, English cocker spaniel, cocker: 0.0053\npug, pug-dog: 0.0044\n\nflutter 推理示例import &#x27;package:tflite_flutter/tflite.dart&#x27;;void loadModel() async &#123;  await Tflite.loadModel(    model: &quot;assets/mobilenet_v2.tflite&quot;,    labels: &quot;assets/labels.txt&quot;,  );&#125;\n","categories":["知识库"],"tags":["ai","大模型"]},{"title":"姿势识别","url":"/2025/07/25/knows/ai/%E5%A7%BF%E5%8A%BF%E8%AF%86%E5%88%AB/","content":"这是一个非常有意义的项目！坐姿识别 App 可以帮助孩子养成良好的学习习惯，预防脊柱侧弯、近视等问题。以下是为你量身定制的 完整开发方案设计，包括功能模块、技术选型、用户交互设计和盈利模式建议。\n\n🎯 一、产品定位\n\n\n名称\n示例\n\n\n\n应用名称\n“姿势守护” &#x2F; “坐得正” &#x2F; “小树苗坐姿助手”\n\n\n目标用户\n6-12 岁小学生及家长\n\n\n核心功能\n实时识别坐姿是否正确，提供提醒与纠正建议\n\n\n使用场景\n写作业、上网课、阅读、使用平板等\n\n\n\n🧠 二、核心功能模块设计1. ✅ 坐姿识别（AI 视频分析）技术实现：\n使用 摄像头实时采集画面\n使用 姿态估计模型（如 MediaPipe Pose 或 OpenPose）识别关键点\n判断是否符合标准坐姿（背部挺直、双脚平放、眼睛与书本距离合理等）\n\n输出判断指标：\n头部是否前倾\n背部是否弯曲\n手臂是否自然下垂\n眼睛与屏幕&#x2F;书本的距离是否合理\n\n提示方式：\n音频提示：“你的姿势不太对哦~”\n图形化反馈：绿色表示正确，红色表示错误\n每次错误后给予一次指导动画或语音说明\n\n\n2. ✅ 学习时间管理功能说明：\n设置每次学习时长（例如 30 分钟）\n自动记录学习时间和坐姿正确率\n提供休息提醒（每 45 分钟提醒活动身体）\n\n数据展示：\n每日坐姿得分\n每周进步趋势图\n孩子的学习报告（可导出 PDF 或分享给家长）\n\n\n3. ✅ 游戏化激励机制设计思路：\n通过积分、勋章、虚拟宠物等方式激励孩子持续使用\n每次坐姿正确即可获得“健康币”，用于解锁新角色或皮肤\n家长端可以看到孩子的成长数据并给予奖励\n\n\n4. ✅ 家长控制面板功能说明：\n查看孩子坐姿历史记录\n设置允许使用时间段（防沉迷）\n接收异常坐姿提醒通知\n导出学习报告（PDF&#x2F;Excel）\n\n\n5. ✅ AR 姿势教学（进阶功能）功能说明：\n通过 AR 模拟正确坐姿\n孩子可以对着镜子模仿\n提供语音引导和动作评分\n\n\n🔧 三、技术选型建议\n\n\n模块\n技术栈\n说明\n\n\n\nApp 开发\nFlutter（Dart）\n跨平台（iOS + Android），开发效率高\n\n\nAI 姿态识别\nMediaPipe Pose &#x2F; TensorFlow Lite\n轻量级模型，适合移动端部署\n\n\n数据存储\nFirebase &#x2F; SQLite\n用户数据本地+云端同步\n\n\n图像处理\nOpenCV &#x2F; Dart 的 image 库\n用于预处理和图像增强\n\n\n推送通知\nFirebase Cloud Messaging (FCM)\n给家长发送提醒\n\n\n\n🖥️ 四、UI&#x2F;UX 设计建议\n\n\n元素\n设计建议\n\n\n\n主界面\n简洁可爱风格，适合儿童审美\n\n\n提醒图标\n使用卡通形象或动物表情包吸引注意力\n\n\n进度条\n用颜色变化显示坐姿状态\n\n\n成就系统\n使用徽章、金币、虚拟宠物等方式激励\n\n\n家长端\n更加简洁专业，突出数据分析和设置功能\n\n\n\n💰 五、商业模式建议\n\n\n方式\n说明\n\n\n\n免费下载 + 内购\n提供基础功能免费，高级功能内购（如 AR 教学、个性化提醒）\n\n\n订阅制会员\n每月&#x2F;年付费解锁更多内容和功能\n\n\nB2B 合作\n与学校合作，批量采购作为课堂辅助工具\n\n\n广告变现\n为教育类品牌做精准投放（如文具、护眼灯）\n\n\n\n🚀 六、开发阶段规划（敏捷开发）\n\n\n阶段\n时间\n目标\n\n\n\nPhase 1（需求 &amp; UI）\n1-2 周\n确定功能清单，设计原型\n\n\nPhase 2（姿态识别 MVP）\n2-3 周\n实现基本 AI 姿态检测\n\n\nPhase 3（App 功能集成）\n3-4 周\n整合 UI 和 AI，完成核心功能\n\n\nPhase 4（测试 &amp; 上架）\n1-2 周\n测试优化，上架应用商店\n\n\nPhase 5（迭代 &amp; 商业化）\n持续进行\n收集用户反馈，推出付费功能\n\n\n\n🤝 七、我可以帮你做什么？\n✅ 提供完整的代码模板（Flutter + TFLite 姿态识别）\n✅ 教你如何训练和部署自己的姿态识别模型\n✅ 教你如何接入 Firebase 实现数据统计和推送通知\n✅ 提供 UI&#x2F;UX 设计参考图和资源推荐\n✅ 教你如何申请 App Store &#x2F; Google Play 上架\n\n\n🚀 如果你现在就想开始告诉我你想做的第一个功能，比如：\n\n“我想先做一个简单的坐姿识别器”\n“我想做一个带 AR 教学的版本”\n“我想做一个面向学校的 B2B 解决方案”\n\n我会立即给你一份详细的开发指南和代码 😊\n","categories":["知识库"],"tags":["ai","大模型"]},{"title":"npm相关","url":"/2025/07/02/knows/node&js/npm%E7%9B%B8%E5%85%B3/","content":"项目运行在 node 18 下出错16 下正常，但 18 下出错\n用18会提示node:internal/crypto/hash:67this[kHandle] = new _Hash(algorithm, xofLen);^Error: error:0308010C:digital envelope routines::unsupportedat new Hash (node:internal/crypto/hash:67:19)at Object.createHash (node:crypto:133:10)at BulkUpdateDecorator.hashFactory (/Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:184161:18)at BulkUpdateDecorator.update (/Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:184062:50)at /Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:107101:9at /Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:33829:16at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;opensslErrorStack: [ &#x27;error:03000086:digital envelope routines::initialization error&#x27; ],library: &#x27;digital envelope routines&#x27;,reason: &#x27;unsupported&#x27;,code: &#x27;ERR_OSSL_EVP_UNSUPPORTED&#x27;&#125;Node.js v18.0.0\n\n可以在命令行下直接运行\nexport NODE_OPTIONS=&quot;--openssl-legacy-provider --max-old-space-size=8192&quot;npm run dev\n\n在.env.local 下运行\nNODE_OPTIONS=--openssl-legacy-provider --max-old-space-size=8192\n","categories":["知识库"],"tags":["npm"]},{"title":"什么是张量","url":"/2025/09/12/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%A0%E9%87%8F/","content":"“张量”（Tensor）是一个在数学、物理和人工智能（尤其是深度学习）中非常重要的概念。它的含义在不同领域略有不同，但核心思想一致。\n我们从易到难，逐步解释：\n\n一、通俗理解：张量就是“多维数组”你可以把张量理解为数字的容器，根据维度不同，分为：\n\n\n\n维度\n名称\n例子\n类比\n\n\n\n0 维\n标量（Scalar）\n一个数字，如 5、3.14\n只有大小，没有方向\n\n\n1 维\n向量（Vector）\n[1, 2, 3]\n一列数字，像 Excel 的一列\n\n\n2 维\n矩阵（Matrix）\n[[1,2], [3,4]]\n像 Excel 的表格（行和列）\n\n\n3 维\n3D 张量\n[[[1,2],[3,4]], [[5,6],[7,8]]]\n像一堆矩阵叠在一起\n\n\n4 维及以上\n高维张量\n常用于图像、视频、批量数据\n多层“数据立方体”\n\n\n\n✅ 张量 &#x3D; 多维数组，是标量、向量、矩阵的推广。\n\n\n二、举个生活中的例子 🌰例子 1：一张灰度图片\n大小是 28×28 像素\n每个像素是一个数字（0~255 表示黑白）\n它就是一个 2D 张量：形状为 (28, 28)\n\n例子 2：一张彩色图片（如 RGB）\n大小 28×28，有 3 个颜色通道（红、绿、蓝）\n它是一个 3D 张量：形状为 (28, 28, 3)\n\n例子 3：一批彩色图片（如深度学习中）\n一次处理 32 张 28×28×3 的图片\n这就是一个 4D 张量：形状为 (32, 28, 28, 3)\n第一维：32 张图（批量大小）\n后三维：每张图的结构\n\n\n\n\n三、在深度学习中的作用（如 TensorFlow、PyTorch）在 AI 框架中：\n\n所有数据（图片、文字、音频）都会被转换成张量\n神经网络的输入、输出、权重、梯度……全是张量\n所有计算（加减乘除、卷积、矩阵乘）都是在张量上进行的\n\n\n🔧 例如：你输入一张猫的图片 → 被转成一个 4D 张量 → 经过神经网络层层计算 → 输出一个 1D 张量表示“是猫的概率”\n\n\n四、数学&#x2F;物理中的张量（进阶理解）在物理和微分几何中，张量更强调在坐标变换下保持不变的性质，用于描述：\n\n应力、应变（工程）\n电磁场（物理）\n时空弯曲（广义相对论）\n\n\n⚠️ 这个定义更抽象，涉及“协变”“逆变”等概念，普通用户了解即可。\n\n\n五、关键概念总结\n\n\n术语\n含义\n\n\n\n形状（Shape）\n张量的维度结构，如 (3, 4) 表示 3 行 4 列\n\n\n秩（Rank）\n张量的维度数，如矩阵是秩为 2 的张量\n\n\n数据类型（dtype）\n张量中元素的类型，如 float32、int64\n\n\n\n✅ 总结一句话：\n张量就是“多维数组”，是表示和处理数据的通用工具，从一个数字到图像、视频、批量样本，都可以用张量来表示。\n\n📌 在 AI 时代，你可以说：\n\n“张量是深度学习的血液”，几乎所有计算都围绕它展开。\n\n\n如果你在学习 PyTorch 或 TensorFlow，你会频繁看到：\nimport torchx = torch.tensor([[1, 2], [3, 4]])  # 创建一个 2D 张量print(x.shape)  # 输出: torch.Size([2, 2])\n\n这就是张量的实际使用方式。\n","categories":["知识库"],"tags":["ai","大模型","张量"]},{"title":"celery 使用","url":"/2025/06/11/knows/python/celery/","content":"celery 使用beat 和 worker 一起使用\ncelery -A projectname worker -l DEBUG -B -l DEBUG\n\n分开执行\ncelery -A projectname beat -l DEBUG\n\ncelery -A srereport worker -Q reports_queue -l DEBUG\n\n上面的-Q 是配置了队列参数\n有队列时，注意要在代码里加上队列名@shared_task(queue=&#x27;reports_queue&#x27;)def some_task(method_type: str):\n\n根据 task_id 查看任务状态celery -A srereport inspect query_task 03ae7485-a86b-4d6d-aaee-1bda50978a26\n","categories":["知识库","python"],"tags":["celery"]},{"title":"pyenv 使用","url":"/2025/05/14/knows/python/pyenv%E4%BD%BF%E7%94%A8/","content":"pyenv 使用要使用 pyenv 创建一个名为 ai 的新虚拟环境，您可以按照以下步骤操作：\n\n确保已安装 pyenv 和 pyenv-virtualenv首先，确保您已经在系统中安装了 pyenv 和 pyenv-virtualenv。如果还没有安装，可以参考以下步骤进行安装：安装 pyenv\n\n使用 Homebrew 安装（适用于 macOS）brew install pyenv\n\n或者使用官方安装脚本curl https://pyenv.run | bash\n\n安装完成后，根据提示将以下内容添加到您的 shell 配置文件（如 .bashrc, .zshrc）中：\nexport PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init --path)&quot;eval &quot;$(pyenv virtualenv-init -)&quot;\n\n然后，重新加载配置文件：source ~/.bashrc  # 或者 source ~/.zshrc\n\n安装 pyenv-virtualenv如果您使用的是 pyenv 官方安装脚本，pyenv-virtualenv 通常已经包含在内。如果没有，可以通过以下方式安装：\n使用 Homebrew 安装（适用于 macOS）brew install pyenv-virtualenv\n\n或者通过 PyPI 安装\n# 或者通过 PyPI 安装pip install pyenv-virtualenv\n\n\n安装所需的 Python 版本在创建虚拟环境之前，确保您已经安装了所需的 Python 版本。例如，安装 Python 3.10.0：\n\npyenv install 3.10.0\n\n您可以通过以下命令查看可用的 Python 版本：\npyenv install --list`\n\n\n创建虚拟环境使用以下命令创建一个名为 ai 的虚拟环境，并指定 Python 版本（例如 3.10.0）：\n\npyenv virtualenv 3.10.0 ai\n\n如果您希望虚拟环境使用系统默认的 Python 版本，可以省略版本号：\npyenv virtualenv ai\n\n\n激活虚拟环境激活刚刚创建的 ai 虚拟环境：\n\npyenv activate ai\n\n激活后，您的命令提示符通常会显示当前激活的虚拟环境名称 (ai)。 5. 验证虚拟环境您可以通过以下命令验证当前 Python 版本和虚拟环境：\npython --version\n\n输出应类似于：Python 3.10.0\n\n安装项目依赖在虚拟环境中，您可以像平常一样使用 pip 安装所需的包。例如：\n\npip install numpy pandas matplotlib\n\n\n退出虚拟环境当您完成工作并希望退出虚拟环境时，可以使用以下命令：\n\npyenv deactivate\n\n\n列出所有虚拟环境要查看系统中所有已创建的虚拟环境，可以使用：\n\npyenv virtualenvs\n\n\n删除虚拟环境如果您不再需要某个虚拟环境，可以使用以下命令删除它：\n\npyenv uninstall ai\n\npyenv virtualenv-delete sla\n\n常见问题排查pyenv: command not found确保已将 pyenv 的路径添加到您的 shell 配置文件中，并重新加载配置。virtualenv: command not found确保已安装 pyenv-virtualenv 并正确初始化。虚拟环境未激活确认使用 pyenv activate ai 激活虚拟环境，并检查命令提示符是否显示 (ai)。\n通过以上步骤，您应该能够成功使用 pyenv 创建和管理名为 ai 的虚拟环境。如果您遇到任何问题，请随时提问！\nenviron 库有缓存改了环境变量，在本地调试时一定要先清空缓存\nimport environimport osfrom pathlib import Pathenv = environ.Env(DEBUG=(bool, False))env_file = os.path.join(Path(__file__).resolve().parent.parent, &#x27;.env&#x27;)env.read_env(env_file, overwrite=True)  # 使用 overwrite=True 强制重新读取\n","categories":["知识库","python"],"tags":["pyenv"]},{"title":"git必学命令","url":"/2025/07/23/knows/git/git%E5%BF%85%E5%AD%A6%E5%91%BD%E4%BB%A4/","content":"git 必学命令git reset –hardgit reset –hard 是 Git 中一个非常强大但也需要谨慎使用的命令。它用于将工作目录和暂存区（index）都重置到某个提交（commit）的状态，丢弃所有未提交的更改。\n🚨 使用前请注意：–hard 选项会永久删除当前工作目录中未提交的修改！所以在使用这个命令之前，请确保你已经保存了重要的更改，或者确认这些更改可以被丢弃。✅ 命令格式\ngit reset --hard [commit]\n\n参数说明：参数 含义–hard 将工作目录、暂存区、HEAD 都重置为指定 commit 的状态[commit] 指定要回退到的提交，如 HEAD~1、abc1234 等。如果省略，默认是 HEAD✅ 示例用法\n\n回退到最后一次提交（放弃所有本地修改）\n\ngit reset --hard HEAD\n\n作用：丢弃所有未提交的更改（包括暂存区和工作区），回到上一次提交的状态。\n\n回退到上一个提交（撤销最后一次提交）\n\ngit reset --hard HEAD~1\n\n作用：将分支指针移动到上一个提交，并清空工作区和暂存区的内容。\n\n回退到某个具体的提交哈希值\n\ngit reset --hard abc1234567890abcdef\n\n作用：将工作目录恢复到 abc1234… 提交时的状态。\n🔄 git reset 的三种模式对比全屏复制模式 作用–soft 仅移动 HEAD 指针，保留暂存区和工作区的更改–mixed（默认） 移动 HEAD 和暂存区，但保留工作区的更改（适合撤销 add 但保留修改）–hard 移动 HEAD、暂存区、工作区，完全丢弃未提交的更改（最彻底的回退）🛠️ 实际应用场景全屏复制场景 推荐命令撤销最近一次提交 git reset –hard HEAD~1弃掉本地所有未提交的修改 git reset –hard HEAD从远程拉取后强制同步 git fetch origin &amp;&amp; git reset –hard origin&#x2F;branch-name⚠️ 注意事项如果你正在开发中，且有未提交的代码，执行 git reset –hard 会永久丢失这些更改。如果你想保留修改但不想提交，可以使用 git stash 来临时保存。🧩 补充：查看历史提交如果你不确定要回退到哪个提交，可以先查看提交历史：\ngit log --oneline\n\n输出示例：\nabc1234 (HEAD -&gt; main) Add new featuredef5678 Fix bug in loginghi90ab Initial commit你可以选择其中一个 commit 哈希来执行 reset。\n✅ 总结命令 效果git reset –hard 弃掉所有未提交的更改，回到上次提交的状态git reset –hard HEAD~1 撤销最后一次提交，并清除所有修改git reset –hard  将工作目录恢复到指定提交的状态如果你还有关于 git revert 或 git checkout 的问题，也可以问我 😊\nreset 命令命令 描述git reset –soft HEAD1 撤销最后一次提交，保留修改在暂存区git reset –mixed HEAD1 撤销最后一次提交，保留修改在工作区（默认）git reset –hard HEAD~1 彻底回退到上一次提交，丢弃所有未提交的更改git stash 暂存当前工作区的更改git stash apply 应用最近一次暂存的更改git revert [commit] 反向提交，安全地撤销某次提交（不会丢失历史）\n日常开发常用组合git checkout -b feature/new-feature       # 创建并切换分支# 修改代码...git add .                                  # 添加更改git commit -m &quot;Add new feature&quot;            # 提交更改git push origin feature/new-feature        # 推送到远程\n\ngit push –set-upstream origin xxx 的意思这个–set-upstream 表示设置当前分支的远程分支，指定关联，以后每次 git push 的时候，会自动推送到远程这个 xxx 分支否则要指定 git push origin xxx\n","categories":["知识库"],"tags":["git"]},{"title":"误添加的文件，怎么删除","url":"/2025/05/16/knows/git/%E8%AF%AF%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%96%87%E4%BB%B6/","content":"误添加的文件，怎么删除将 .env 配置文件添加到了 git 仓库上，因为里面有重要的配置信息，所以需要删除。\n\n先将.env 文件从 git 仓库中删除\n\ngit rm --cached .env\n\n\n推送一次\n\ngit commit -m &quot;Remove .env file from repository&quot;git push origin main\n","categories":["知识库"],"tags":["git"]},{"title":"supervisor配置问题总结","url":"/2025/05/13/knows/python/supervisor%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","content":"问题 1：supervisor 启动 gunicorn 报错：显示\n\ngunicorn FATAL Exited too quickly (process log may have details)但查找进程显示有 gunicorn 进程\n\nps -ef | grep gunicorn\n\n通过 AI 分析：\n\ndaemon &#x3D; True 与 Supervisor 冲突Gunicorn 的 daemon &#x3D; True：会让 Gunicorn 以后台守护进程方式运行（脱离终端），而 Supervisor 本身会管理进程的前台运行。两者同时启用时，Supervisor &gt; 会认为 Gunicorn 已退出（因为 Gunicorn 主进程已退出），导致标记为 FATAL。解决方案：移除 gunicorn 配置文件里的 daemon &#x3D; True，让 Gunicorn 以前台进程方式运行，由 Supervisor 管理。\n\n问题 2：supervisor 启动的项目，还需要指定 pidfile 吗？：显式指定 pidfile,但查看目录并不会生成 pid 文件查 AI：\n\n当你使用 Supervisor 管理应用时，通常不需要再为应用单独配置 pidfile。Supervisor 本身会自动管理所有被监控进程的 PID 文件（进程标识符文件），用于跟踪进程状态（如启动、停止、重启）。以下是详细说明：为什么不需要应用自定义 pidfile？\n\nSupervisor 自动管理 PID 文件Supervisor 会为每个被管理的程序生成一个 .pid 文件，默认路径为：\n\n\n\n/var/run/supervisor/supervisord.pid/tmp/supervisor-&lt;program&gt;.pid\n\n或根据你的配置指定路径。作用：Supervisor 使用 .pid 文件来记录进程的 PID，确保进程状态可追踪。\n\n\n\n应用自定义 pidfile 的潜在问题冲突风险：如果应用（如 Gunicorn）也配置了 pidfile，可能导致：Supervisor 和应用同时写入同一文件，引发冲突。应用退出后，Supervisor 的 .pid 文件可能残留，导致下次启动失败。冗余操作：Supervisor 已经管理了进程生命周期，应用的 pidfile 通常是多余的。\n\n\n参考：CentOS+Django+uWSGI+Celery+Supervisor 配置\n","categories":["知识库","python"],"tags":["supervisor","gunicorn"]},{"title":"git问题解决","url":"/2025/05/16/knows/git/git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"git 问题解决\ngit push –set-upstream origin master\nPlease contact your system administrator.\nAdd correct host key in &#x2F;Users&#x2F;xxx&#x2F;.ssh&#x2F;known_hosts to get rid of this message.\nOffending RSA key in &#x2F;Users&#x2F;xxx&#x2F;.ssh&#x2F;known_hosts:3\nHost key for github.com has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n\n应该怎么处理\n这个问题是在执行 git push 命令时，因远程主机密钥更改导致的主机密钥验证失败。以下是几种处理方法：\n1、手动删除错误密钥可以使用以下命令删除 known_hosts 文件中错误的密钥：\n2、使用 ssh-keygen 重新生成密钥 或 将 SSH 密钥添加到 GitHub 账户生成新密钥ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;\n\n将 SSH 密钥添加到 GitHub 账户cat ~/.ssh/id_ed25519.pub\n\n3、测试连接ssh -T git@github.com\n","categories":["知识库"],"tags":["git"]},{"title":"adb 常用操作","url":"/2025/05/23/knows/flutter/%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/","content":"列出虚拟设备adb devices\n\n连接虚拟设备,进入 shelladb -s 6c49ee85 shell\n\n保存文件String? html = await webView.getHtml();setState(() &#123;htmlContent = html;&#125;);print(&#x27;Full Page HTML ($&#123;html?.length ?? 0&#125; characters): $html&#x27;);String las = html!.substring(html.length - 1000);print(&quot;last 1000: $las&quot;);final directory = await getApplicationDocumentsDirectory();final filePath = &#x27;$&#123;directory.path&#125;/douyin_html.html&#x27;;// 3. 写入文件await File(filePath).writeAsString(html ?? &#x27;&#x27;);print(&#x27;HTML saved to: $filePath&#x27;);\n\n打印显示 &#x2F;data&#x2F;user&#x2F;0&#x2F;wang.awake.video_fetcher&#x2F;app_flutter&#x2F;douyin_html.html\n用 adb 命令查看文件run-as wang.awake.video_fetcher\n\n会进入到包目录，此时可以查看包\n用 adb 下载虚拟机的文件adb exec-out run-as wang.awake.yidong cat databases/app.db &gt; app.db\n\n这样就将 app.db 下载到了本地\n注意：只有在 root 或 debug 模式下才能用进入到包目录下载文件\n","categories":["知识库"],"tags":["Flutter"]},{"title":"Dart基础","url":"/2025/05/13/knows/flutter/dart%E5%9F%BA%E7%A1%80/","content":"变量学习1、var 关键字类似于 JavaScript 中的 var，它可以接收任何类型的变量，但最大的不同是 Dart 中 var 变量一旦赋值，类型便会确定，则不能再改变其类型，如：\n// 定义变量var name = &quot;张三&quot;;name = 123; // 报错;\n","categories":["知识库"],"tags":["Flutter","Dart"]},{"title":"Flutter基础组件","url":"/2025/05/12/knows/flutter/%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/","content":"文本组件\nText：用于显示文本。\nRichText：用于显示富文本，支持多种样式。\nDefaultTextStyle：用于设置默认文本样式。\nSelectableText：用于显示可选择的文本。\nFittedBox：用于调整文本大小以适应可用空间。\nTextSpan：用于构建富文本的文本片段。\nTextStyle：用于定义文本的样式，如字体、大小、颜色等。\nTextDecoration：用于定义文本的装饰，如下划线、删除线等。\nTextAlign：用于定义文本的对齐方式，如左对齐、右对齐、居中对齐等。\nTextOverflow：用于定义文本溢出时的处理方式，如截断、省略号等。\nTextDirection：用于定义文本的方向，如左到右、右到左等。\nTextScaleFactor：用于定义文本的缩放因子。\nTextWidthBasis：用于定义文本的宽度基准。\nTextHeightBehavior：用于定义文本的高度行为。\nTextBaseline：用于定义文本的基线。\nTextDecorationStyle：用于定义文本装饰的样式，如实线、虚线等。\nTextDecorationColor：用于定义文本装饰的颜色。\n\n布局组件\nContainer：用于创建一个矩形的容器，用于包裹其他组件。\nPadding：用于在容器内添加内边距，用于调整组件的位置。\nMargin：用于在容器外添加外边距，用于调整组件的位置。\n\nSingleChildScrollView\nSingleChildScrollView：用于创建一个单子滚动视图，用于包裹其他组件。\n\n简介SingleChildScrollView 是 Flutter 中的滚动组件。其作用是包裹子组件，当子组件内容超过屏幕可视区域时，允许用户通过滚动查看完整内容。\n当前代码中， SingleChildScrollView 作为 Scaffold 的 body 属性值，内部通过 Padding 和 Column 布局容纳其他子控件（如 TextField 等），确保页面内容超出屏幕时可滚动浏览。\n\nListView：用于创建一个列表视图，用于包裹其他组件。\nGridView：用于创建一个网格视图，用于包裹其他组件。\nStack：用于创建一个堆叠视图，用于包裹其他组件。\nPositioned：用于创建一个可定位的组件，用于调整组件的位置。\n\n交互组件\nGestureDetector：用于检测用户的手势，如点击、长按、滑动等。\nInkWell：用于创建一个可点击的 ink 效果，用于响应用户的手势。\nDraggable：用于创建可拖动的组件。\nDropTarget：用于创建可接收拖动组件的目标。\nDragTarget：用于创建可接收拖动组件的目标。\nDragSource：用于创建可拖动的组件。\nDragSourceListener：用于监听拖动组件的状态。\nDropTargetListener：用于监听接收拖动组件的状态。\nDragTargetAcceptor：用于接受拖动组件的目标。\nDragTargetAcceptorListener：用于监听接收拖动组件的状态。\nDragTargetAcceptorDelegate：用于定义接收拖动组件的目标的行为。\nDragTargetAcceptorDelegateListener：用于监听接收拖动组件的状态。\nDragTargetAcceptorDelegateBuilder：用于构建接收拖动组件的目标的行为。\n\n动画组件\nAnimatedContainer：用于创建一个可动画的容器，用于调整组件的位置、大小、颜色等。\nAnimatedOpacity：用于创建一个可动画的透明度，用于调整组件的透明度。\nAnimatedPositioned：用于创建一个可动画的位置，用于调整组件的位置。\nAnimatedPadding：用于创建一个可动画的内边距，用于调整组件的位置。\nAnimatedMargin：用于创建一个可动画的外边距，用于调整组件的位置。\nAnimatedSize：用于创建一个可动画的大小，用于调整组件的大小。\nAnimatedAlign：用于创建一个可动画的对齐方式，用于调整组件的位置。\n\n弹窗组件\nAlertDialog：用于创建一个对话框，用于显示提示信息。\nSimpleDialog：用于创建一个简单的对话框，用于显示提示信息。\nBottomSheet：用于创建一个底部弹出的对话框，用于显示提示信息。\nDialog：用于创建一个对话框，用于显示提示信息。\nSnackBar：用于创建一个弹出的提示信息，用于显示提示信息。\nBottomAppBar：用于创建一个底部弹出的对话框，用于显示提示信息。\nBottomNavigationBar：用于创建一个底部导航栏，用于显示提示信息。\nBottomNavigationBarItem：用于创建一个底部导航栏的条目，用于显示提示信息。\n\n","categories":["知识库"],"tags":["Flutter"]},{"title":"Flutter基础组件","url":"/2025/05/30/knows/flutter/%E5%B8%B8%E7%94%A8%E7%B1%BB/","content":"Completer其作用是创建 Future 对象，并且能手动控制该对象的完成状态 1 。借助 Completer，开发者能够在异步操作完成后，将结果传递给对应的 Future 对象，这样依赖该 Future 的代码就可以继续执行。\n下面是一个简单的示例代码，展示了如何使用 Completer：\nimport &#x27;dart:async&#x27;;void main() &#123;  // 创建一个 Completer 对象  Completer&lt;String&gt; completer = Completer&lt;String&gt;();  // 获取 Completer 关联的 Future 对象  Future&lt;String&gt; future = completer.future;  // 为 Future 对象添加回调函数  future.then((value) &#123;    print(&#x27;Future 完成，结果是: $value&#x27;);  &#125;);  // 模拟异步操作  Future.delayed(Duration(seconds: 2), () &#123;    // 完成 Completer，并传递结果    completer.complete(&#x27;操作完成&#x27;);  &#125;);&#125;\n\n在这个示例中，我们创建了一个 Completer 对象，获取其关联的 Future 对象，并为该 Future 添加了一个回调函数。接着模拟了一个异步操作，在操作完成后调用 completer.complete 方法，将结果传递给 Future ，触发回调函数的执行。\n","categories":["知识库"],"tags":["Flutter"]},{"title":"加载assets文件","url":"/2025/05/26/knows/flutter/%E5%8A%A0%E8%BD%BDassets%E6%96%87%E4%BB%B6/","content":"将资源文件加到 assets 目录如 assets&#x2F;key&#x2F;public.pem 文件\n读取资源文件读取前先在 pubspec.yaml 中配置\nflutter:    assets:        - assets/key/public.pem\n\n读取资源文件import &#x27;package:flutter/services.dart&#x27;;String publicKey = await rootBundle.loadString(&#x27;assets/key/public.pem&#x27;);\n","categories":["知识库"],"tags":["Flutter"]},{"title":"常见目录","url":"/2025/07/02/knows/flutter/%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95/","content":"常见目录Android 标准目录说明：DCIM - 所有 Android 设备都有，相机默认存储目录Pictures - 大部分设备有，但不是强制要求Movies - 部分设备有，用于存储视频Download - 所有设备都有，下载目录\nIOS 标准目录说明：iOS 没有传统的文件目录结构，使用相册概念relativePath 在 iOS 上是相册名称，不是文件路径权限管理更严格，需要专门的照片库权限iOS 14+ 引入了有限权限模式自定义相册创建失败时，应该有备用策略（保存到默认相册）沙盒机制限制，只能通过系统 API 访问照片库这就是为什么我们在处理 iOS 时需要与 Android 完全不同的策略！\n应用沙盒应用沙盒&#x2F;├── Documents&#x2F; # 用户文档，会被 iTunes 备份├── Library&#x2F;│ ├── Caches&#x2F; # 缓存文件，系统可能清理│ └── Preferences&#x2F; # 应用偏好设置├── tmp&#x2F; # 临时文件，系统会定期清理└── SystemData&#x2F; # 系统数据（iOS 14+）\n照片相册类型&#x2F;&#x2F; 系统预置相册（不能删除）‘Camera Roll’ &#x2F;&#x2F; 相机胶卷（主相册）‘Favorites’ &#x2F;&#x2F; 收藏‘Recently Added’ &#x2F;&#x2F; 最近添加‘Screenshots’ &#x2F;&#x2F; 屏幕截图‘Selfies’ &#x2F;&#x2F; 自拍‘Live Photos’ &#x2F;&#x2F; Live 照片‘Portrait’ &#x2F;&#x2F; 人像‘Panoramas’ &#x2F;&#x2F; 全景‘Videos’ &#x2F;&#x2F; 视频‘Slo-mo’ &#x2F;&#x2F; 慢动作‘Time-lapse’ &#x2F;&#x2F; 延时摄影‘Bursts’ &#x2F;&#x2F; 连拍‘Recently Deleted’ &#x2F;&#x2F; 最近删除\n应用// 创建/保存到自定义相册final result = await PhotoManager.editor.saveImage(  imageBytes,  filename: fileName,  title: fileName,  relativePath: &#x27;易动收藏&#x27;, // 相册名称，不是路径);\n","categories":["知识库"],"tags":["Flutter"]},{"title":"模拟器相关","url":"/2025/07/25/knows/flutter/%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9B%B8%E5%85%B3/","content":"模拟长按动作\n使用鼠标模拟「长按」操作步骤：\n\n在模拟器中打开包含图片的应用（如 Safari 或你的 Flutter 应用）。将鼠标悬停在图片上。按住鼠标左键不放（保持 1-2 秒），模拟器会自动触发长按事件。如果出现菜单（如保存图片选项），直接选择即可。替代方案（更可靠）：\nControl + 点击图片（Mac）或 右键点击图片（Windows），直接弹出上下文菜单（如保存图片）。\n","categories":["知识库"],"tags":["ios模拟器"]},{"title":"虚拟机相关","url":"/2025/05/30/knows/flutter/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/","content":"手动启动虚拟机1. 列出虚拟机# 列出所有已创建的虚拟设备emulator -list-avds# 或者使用 avdmanageravdmanager list avd\n\n2. 启动虚拟机# 基本启动emulator -avd [AVD名称]# 后台启动（不阻塞命令行）emulator -avd [AVD名称] &amp;# Windows 后台启动start emulator -avd [AVD名称]# 指定分辨率启动emulator -avd [AVD名称] -skin 1080x1920# 冷启动（清除状态）emulator -avd [AVD名称] -wipe-data# 无声启动emulator -avd [AVD名称] -no-audio# 显示详细日志emulator -avd [AVD名称] -verbose\n\n3.性能相关# 启用硬件加速emulator -avd [AVD名称] -gpu host# 分配更多内存emulator -avd [AVD名称] -memory 2048# 启用多核支持emulator -avd [AVD名称] -cores 4# 启用快速启动emulator -avd [AVD名称] -no-snapshot-save\n","categories":["知识库"],"tags":["Flutter"]},{"title":"视频播放测试地址","url":"/2025/05/20/knows/flutter/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80/","content":"最近在开发视频播放相关的业务功能，开发测试时，需要涉及到 MP4、M3U8 等视频格式。我每次找测试视频地址时，都要找很久，现在把我在网上收集到的 MP4、M3U8 格式视频地址放在这里，希望帮助到正在进行视频播放开发的你。\nMP4 格式海洋：http://vjs.zencdn.net/v/oceans.mp4\n西瓜视频 Demo：https://sf1-cdn-tos.huoshanstatic.com/obj/media-fe/xgplayer_doc_video/mp4/xgplayer-demo-360p.mp4\n大兔子：http://www.w3school.com.cn/example/html5/mov_bbb.mp4\n大灰熊：https://www.w3schools.com/html/movie.mp4\n冰川：https://media.w3.org/2010/05/sintel/trailer.mp4\n新闻视频 1：https://stream7.iqilu.com/10339/upload_transcode/202002/09/20200209105011F0zPoYzHry.mp4\n新闻视频 2：https://stream7.iqilu.com/10339/upload_transcode/202002/09/20200209104902N3v5Vpxuvb.mp4\nM3U8 格式西瓜播放器 Demo：https://sf1-cdn-tos.huoshanstatic.com/obj/media-fe/xgplayer_doc_video/hls/xgplayer-demo.m3u8\n大白兔：https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8\n","categories":["知识库"],"tags":["Flutter","视频"]},{"title":"打包配置sha1","url":"/2025/05/26/knows/flutter/%E9%85%8D%E7%BD%AEsha1/","content":"主要参考：https://juejin.cn/post/7129495755207180319\n生成 key 目录mkdir ~/dapp/keys/\n\n生成私钥keytool -genkey -v -keystore ~/dapp/keys/prod_key.jks -keyalg RSA -keysize 2048 -validity 100000 -alias prod_key\n\nlocal.properties 添加上述设置storePassword = xxxxxxkeyPassword = xxxxxxkeyAlias = prod_keystoreFile = /xxxx/xxxx/dapp/keys/prod_key.jks\n\n到项目下的 android&#x2F;app&#x2F;build.gradle 中添加import java.util.Properties...android &#123;    signingConfigs &#123;        create(&quot;release&quot;) &#123;            // 加载 local.properties 文件            val localProperties = Properties().apply &#123;                load(rootProject.file(&quot;local.properties&quot;).inputStream())            &#125;            // 读取配置项            storeFile = file(localProperties.getProperty(&quot;storeFile&quot;))            storePassword = localProperties.getProperty(&quot;storePassword&quot;)            keyAlias = localProperties.getProperty(&quot;keyAlias&quot;)            keyPassword = localProperties.getProperty(&quot;keyPassword&quot;)        &#125;    &#125;    buildTypes &#123;        release &#123;            signingConfig = signingConfigs.getByName(&quot;release&quot;)        &#125;        debug &#123;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)        &#125;    &#125;&#125;\n\n测试签名./gradlew signingReport\n\n打包flutter build apk --release\n","categories":["知识库"],"tags":["Flutter"]},{"title":"Flutter配置相关","url":"/2025/05/20/knows/flutter/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/","content":"配置 Java 环境1、安装 Java\nbrew install openjdk@21\n\n2、配置环境变量写进.bash_profile\nexport JAVA_HOME=/opt/homebrew/opt/openjdk@21export PATH=$JAVA_HOME/bin:$PATH\n\n3、验证\njava -version\n\n注意：gradle 版本与 java 版本要匹配https://docs.gradle.org/current/userguide/compatibility.html#java\n换源build.gradle.kts\nallprojects &#123;    repositories &#123;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;    &#125;&#125;\n\nsettings.gradle.kts\nrepositories &#123;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;&#125;\n\nbuild.gradle.kts 文件中的仓库配置是用于项目所有模块的全局配置，而 settings.gradle.kts 中的配置是用于插件管理的。在 Gradle 项目中，通常需要在这两个地方都配置仓库地址，以确保所有依赖项都能正确下载。建议将 build.gradle.kts 中的仓库配置也替换为阿里云镜像源，以保持一致性并提高构建速度。\n出错\nWhat went wrong:Plugin [id: ‘com.android.application’, version: ‘8.7.0’, apply: false] was not found in any of the following sources:\n\n\nGradle Core Plugins (plugin is not in ‘org.gradle’ namespace)\nIncluded Builds (No included builds contain this plugin)\nPlugin Repositories (could not resolve plugin artifact ‘com.android.application:com.android.application.gradle.plugin:8.7.0’)Searched in the following repositories:maven(https://maven.aliyun.com/repository/public)maven2(https://maven.aliyun.com/repository/google)maven3(https://maven.aliyun.com/repository/gradle-plugin)\n\n错误信息显示无法找到 com.android.application 插件，这是因为阿里云镜像可能没有完全同步 Google 的仓库内容。建议在 settings.gradle.kts 中保留 Google 的官方仓库，同时使用阿里云镜像。以下是修改后的配置：\nrepositories &#123;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;    google()    mavenCentral()&#125;\n\n查看 Android 模拟器版本号的两种方法：1、ADB 查看\nadb shell getprop ro.build.version.releaseadb shell getprop ro.build.version.sdk\n\n第一条命令输出 Android 系统版本（如 13），第二条输出 API 级别（如 33）\n2、在模拟器界面查看\n\n打开模拟器\n进入 Settings → System → About phone → Android version\n连续点击 “Build number” 7 次可解锁开发者选项\n\nAndroid 存储权限变更&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;\n\n如果 ios 目录被删除，应该怎么办？flutter create --platform ios .\n\n这样会在当前目录下生成一个新的 ios 目录，其中包含了 Flutter 所需的所有文件和配置。\n","categories":["知识库"],"tags":["Flutter","Java"]},{"title":"什么是敞口","url":"/2025/09/17/knows/%E7%BB%8F%E6%B5%8E/%E4%BB%80%E4%B9%88%E5%8F%AB%E6%95%9E%E5%8F%A3/","content":"“敞口”是一个在金融领域非常常用的术语，英文对应的是 Exposure。\n简单来说，“敞口”指的是你（或你的投资组合）在某个特定风险因素面前暴露的程度，也就是你可能因此遭受损失或获得收益的“风险&#x2F;机会规模”。\n你可以把它理解为 “风险暴露” 或 “风险暴露头寸”。\n\n🌰 举个通俗的例子：假设你买了 100 股腾讯的股票，每股 500 元，总共投入 5 万元。\n\n你的“腾讯股票敞口”就是 5 万元。\n这意味着：腾讯股价每上涨 1%，你赚 500 元；每下跌 1%，你就亏 500 元。\n你在这 5 万元上，完全“暴露”在腾讯股价波动的风险（和机会）之下。\n\n\n🔍 常见的“敞口”类型：\n\n\n敞口类型\n含义\n例子\n\n\n\n市场敞口\n对整体市场波动的风险暴露\n你持有 A 股，就对 A 股市场有敞口\n\n\n行业敞口\n对某个行业的风险暴露\n你重仓新能源车股票，就对新能源行业有高敞口\n\n\n个股敞口\n对某一只股票的风险暴露\n你持有大量茅台股票，茅台就是你的“个股敞口”\n\n\n货币敞口\n对汇率波动的风险暴露\n你投资了美股，就对美元&#x2F;人民币汇率有敞口\n\n\n利率敞口\n对利率变化的风险暴露\n银行放贷多，就对利率下行有敞口（利息收入减少）\n\n\n信用敞口\n对借款人违约的风险暴露\n银行借给某公司 1 亿，这 1 亿就是信用敞口\n\n\n\n📌 在之前关于 NVDY ETF 的讨论中，“敞口”是什么意思？我们说 NVDY “复制英伟达的敞口”，意思是：\n\nNVDY 虽然不直接买英伟达的股票，但它通过期货、期权等工具，让自己基金的表现尽可能地跟随英伟达股价的涨跌。也就是说，投资者通过买 NVDY，就“暴露”在了英伟达股价波动的风险和机会中——这就是获得了“英伟达的敞口”。\n\n\n✅ 总结一句话：\n“敞口”就是你“押了多少钱”在某个风险上。敞口越大，潜在的收益和亏损空间就越大。\n\n理解“敞口”有助于你评估投资组合的风险集中度，避免把所有鸡蛋放在一个篮子里。\n","categories":["知识库"],"tags":["投资","股票","敞口"]},{"title":"什么是MCP","url":"/2025/09/22/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AFmcp/","content":"MCP（Model Context Protocol，模型上下文协议）是 AI 领域的一种开放标准通信协议，由 Anthropic 于 2024 年 11 月率先提出，旨在解决大模型（LLM）与外部工具、数据源交互的标准化问题。其核心价值是通过统一接口打破“信息孤岛”，简化开发流程，实现“即插即用”的 AI 应用扩展。\n以下是关键要点解析：\n\n一、MCP 的核心功能与设计目标\n统一交互标准\n\n传统 AI 工具集成需针对不同 API 编写定制化代码，开发成本高、复用性低（N×M 复杂度）；而 MCP 定义通用协议，使工具与模型的交互标准化（N+M 复杂度），显著降低开发门槛。\n类比说明：\n类似USB-C 接口，统一不同设备的连接方式。\n或像万能遥控器，协调多设备协作（如“观影模式”自动关灯+开投影仪）。\n\n\n\n\n动态扩展能力\n\nMCP 允许模型动态发现并调用新工具：例如新增日历服务时，AI 无需修改代码即可直接调用。\n\n\n\n\n二、核心架构与工作流程MCP 采用客户端-服务器模型，包含三个角色：  \n\n\n\n组件\n功能\n实例\n\n\n\nMCP 主机（Host）\n用户交互界面（如聊天机器人、IDE 插件）\nClaude Desktop、Cursor IDE\n\n\nMCP 客户端（Client）\n集成于主机，管理连接与协议解析\n内嵌于 IDE 的通信模块\n\n\nMCP 服务器（Server）\n提供工具或数据访问的轻量服务（如数据库、API、本地文件）\nGitHub MCP Server、Slack MCP 工具包\n\n\n工作流程：\n\n主机通过客户端发现可用服务器，获取工具描述（名称&#x2F;参数&#x2F;功能）；\n用户提问 → 模型生成标准化调用指令 → 发送至 MCP 服务器；\n服务器执行操作（如查询数据库）→ 返回结果 → 模型生成最终回复。\n\n\n三、实际应用场景与案例\n开发效率提升：\n在 Cursor IDE 中连接 Postgres MCP Server，直接执行 SQL 查询，无需切换工具。\n\n\n智能工作流：\n企业客服系统通过 MCP 整合订单数据库+物流 API，自动回复用户“包裹状态”。\n\n\n多模型协作：\n调用图像生成 MCP 服务器（如 Replicate），为代码项目自动生成界面设计。\n\n\n\n\n四、与其他技术的区别\n\n\n技术\n定位\n与 MCP 的关系\n\n\n\nFunction Calling\n单模型调用的功能模块（如 OpenAI 工具调用）\nMCP 的底层实现基础之一，但仅限单一模型。\n\n\nAI Agent\n能自主决策的智能系统\n依赖 MCP 调用工具完成复杂任务（如决策+执行链）。\n\n\n\n五、当前生态与挑战\n生态进展：\n巨头支持：OpenAI、谷歌、阿里、字节等均宣布兼容 MCP 协议。\n工具市场：高德地图、微信读书等已推出官方 MCP 服务器。\n\n\n现存挑战：\n安全性风险：恶意服务器可通过提示词投毒攻击模型（如强制输出特定内容）。\n协议成熟度：部分开发者认为 MCP“为统一而统一”，实际工具复用率仍待验证。\n\n\n\n\n六、总结MCP 通过标准化协议解决了大模型与外部世界的连接难题，成为 AI Agent 落地的关键技术支撑。其价值在于：✅ 降低开发成本：避免重复编写工具适配代码；✅ 增强模型能力：实时获取外部数据（如天气&#x2F;股票）；✅ 促进生态协同：推动工具服务商与模型厂商开放协作。\n\n注：更多技术细节可参考 MCP 官方文档 或开源项目实践（如 MCP-Demo）。\n\n","categories":["知识库"],"tags":["ai","大模型","MCP"]}]