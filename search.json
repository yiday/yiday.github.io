[{"title":"MarkDown学习","url":"/2025/05/12/knows/MarkDown%E5%AD%A6%E4%B9%A0/","content":"标题学习# 一级标题## 二级标题### 三级标题\n\n列表学习- 无序列表- 无序列表- 无序列表\n\n1. 有序列表2. 有序列表3. 有序列表\n\n引用学习&gt; 引用学习\n\n分割线学习---\n\n图片学习![图片名称](图片路径)\n\n超链接学习[超链接名称](超链接路径)或者 跳转到新的窗口[超链接名称](超链接路径 &quot;新窗口&quot;)&#123;target=&quot;_blank&quot;&#125;### 代码学习\n\n代码内容\n\n表格学习要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。\n| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text |\n\n\n\n\nSyntax\nDescription\n\n\n\nHeader\nTitle\n\n\nParagraph\nText\n\n\n","categories":["知识库"]},{"title":"正则表达式","url":"/2025/05/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"正则表达式基础[^&gt;]表示什么？🔍 [] 在正则表达式中的含义：字符类（Character Class）[] 表示字符类，用来定义一组可匹配的字符。\n基本语法：[abc]     // 匹配 a 或 b 或 c 中的任意一个字符[a-z]     // 匹配 a 到 z 的任意小写字母[0-9]     // 匹配 0 到 9 的任意数字[A-Za-z]  // 匹配任意大小写字母\n\n否定字符类：[^abc]    // 匹配除了 a、b、c 之外的任何字符[^0-9]    // 匹配非数字字符[^&gt;]      // 匹配除了 &gt; 之外的任何字符\n\n在你的例子中：[^&gt;]*\n\n分解：\n\n[^&gt;] - 字符类：匹配除了 &gt; 之外的任意一个字符\n* - 量词：表示前面的字符类可以出现 0 次或多次\n\n实际匹配示例：&lt;!-- 原始HTML --&gt;&lt;title data-rh=&quot;true&quot; class=&quot;page-title&quot;&gt;我的标题 - 知乎&lt;/title&gt;&lt;!-- 正则匹配过程 --&gt;&lt;title ← 匹配字面量 [^&gt;\t]* ← 匹配 &quot; data-rh=\\&quot;true\\&quot; class=\\&quot;page-title\\&quot;&quot; &gt; ← 匹配标签结束符 (.*?)\t← 捕获 &quot;我的标题&quot; - 知乎&lt;/title&gt;← 匹配结尾\n\n其他字符类例子：RegExp(r&#x27;[aeiou]&#x27;)     // 匹配元音字母RegExp(r&#x27;[^aeiou]&#x27;)    // 匹配非元音字母RegExp(r&#x27;[0-9]+&#x27;)      // 匹配一个或多个数字RegExp(r&#x27;[a-zA-Z_]&#x27;)   // 匹配字母或下划线RegExp(r&#x27;[^a-zA-Z0-9]&#x27;) // 匹配非字母数字字符\n\n总结：[] 就是用来定义一组字符选择的容器！\n","categories":["知识库"]},{"title":"原来空格这么重要","url":"/2025/10/23/knows/bash/bash%E5%87%BA%E4%BA%86%E4%B8%AA%E9%94%99/","content":"if [ &quot;`hostname`&quot; = &quot;aaaaa&quot;] ;thenecho &quot;start celery0&quot;supervisord -c supervisor/supervisord_celery0.confelseecho &quot;start celeryall&quot;\n\n提示 start.sh: line 53: [: missing &#96;]’\n您遇到的错误 start.sh: line 53: [: missing ]’ 是一个典型的 Shell 脚本语法错误，原因是 if 语句中的条件判断 [ ] 缺少了结尾的 ]。\n🔍 错误定位\n您提供的代码片段是：\nbashif [ “hostname” &#x3D; “aaaaa”] ;thenecho “start celery0”supervisord -c supervisor&#x2F;supervisord_celery0.confelseecho “start celeryall”\n问题出在这一行：\nbashif [ “hostname” &#x3D; “aaaaa”] ;then\n👉 错误原因：”aaaaa”] 这里，”] 紧贴在字符串后面，没有空格，导致 Shell 无法正确解析 [ 命令的参数。\n在 Shell 中，[ 是一个命令（等价于 test），它的参数之间必须用空格分隔。正确的写法应该是：\nbash[ “$var” &#x3D; “value” ]\n而不是：\nbash[ “$var” &#x3D; “value”] # ❌ 错误：] 紧贴字符串\n✅ 修复方法\n将这行代码修改为：\nbashif [ “hostname” &#x3D; “aaaaa” ]; then\n注意：“aaaaa” 和 ] 之间有一个空格。]; 改为 ] ; 或 ] then 前加空格。\n✅ 推荐的更健壮写法\n\n使用 $() 替代反引号（更现代、可读性更好）：bashif [ “$(hostname)” &#x3D; “aaaaa” ]; then\n\n使用 [[]]（Bash 特有，更安全）：bashif [[$(hostname) &#x3D;&#x3D; “aaaaa”]]; then\n\n\n[[]] 对空格和变量处理更宽容，不易出错。\n\n完整修复后的脚本示例：bashif [ “$(hostname)” &#x3D; “aaaaa” ]; thenecho “start celery0”supervisord -c supervisor&#x2F;supervisord_celery0.confelseecho “start celeryall”\n\n这里可以添加启动 celeryall 的命令fi⚠️ 注意：您原脚本中 else 分支只有 echo，没有实际启动命令，可能也需要补充。\n🛠️ 总结\n错误 原因 修复\n\n[: missing ‘]’ [ 命令的参数未正确分隔，] 紧贴字符串 在 “] 前添加空格，改为 “ ]&#96;\n✅ 正确写法：bashif [ “$(hostname)” &#x3D; “aaaaa” ]; then\n修复后，脚本就能正常运行了。\n","categories":["知识库","bash","shell"]},{"title":"什么是ACU","url":"/2025/10/23/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AFACU/","content":"“ACU”是一个多领域缩写词，具体含义取决于应用场景，常见于计算机硬件架构、云计算资源计量、汽车电子控制三大领域，核心差异体现在功能定位和技术特性上：\n一、计算机硬件：地址计算单元（Address Calculation Unit）在 CPU 架构中，ACU 是负责内存地址生成的专用电路，通过并行处理地址运算（如数组索引、指针偏移计算），减少 CPU 周期消耗。例如执行array[i+1]时，ACU 会独立计算目标内存地址，避免占用通用计算核心资源，从而提升指令执行效率。这种设计常见于高性能处理器，尤其在需要频繁内存访问的场景（如图像处理、科学计算）中作用显著。\n二、云计算：计算能力单元（Application&#x2F;Aurora Capacity Unit）1. Azure Compute Unit（Azure 云服务）微软 Azure 用 ACU 标准化不同虚拟机（VM）的 CPU 性能，以 A0 实例（ACU&#x3D;50）为基准，其他实例按相对性能赋值。例如 Ev3 系列 ACU 为 160-190，意味着其计算能力是 A0 的 3.2-3.8 倍。用户可通过 ACU 值直观比较不同 VM 规格的性能，例如选择 ACU&#x3D;200 的实例处理 CPU 密集型任务。\n2. Aurora Capacity Unit（AWS 数据库）AWS Aurora Serverless v2 将计算资源抽象为 ACU，1 个 ACU 包含0.5-4 vCPU、弹性内存（最高 30GB）和网络带宽，可根据负载自动扩缩容。其优势在于毫秒级响应速度——从 0.5 ACU 扩容至 128 ACU 仅需 5 秒，远快于传统 RDS 实例的分钟级调整。电商平台可利用此特性应对流量波动，例如促销活动期间自动提升 ACU 以保障数据库性能。\n三、汽车电子：自适应控制单元（Adaptive Control Unit）英特尔在 2025 年 CES 推出的 ACU 是面向电动汽车的域控制器芯片，如 ACU U310。它集成 CPU 核与灵活逻辑单元（FLU），能同时处理实时控制算法（如动力总成调节）和安全关键任务，替代传统分散的微控制器（MCU）。例如通过算法优化，ACU 可降低电动车 40%的动力系统能量损耗，在 WLTP 测试中提升 3%-5%续航效率。Stellantis Motorsports 已将其用于赛车逆变器控制，通过能量回收提升赛道性能。\n四、跨场景对比与识别技巧\n\n\n领域\n核心功能\n典型场景\n关键特征词\n\n\n\n硬件架构\n内存地址计算\nCPU 设计、汇编指令优化\n地址生成、并行处理\n\n\n云计算\n资源计量与弹性分配\nVM 选型、数据库扩缩容\n性能基准、自动扩缩\n\n\n汽车电子\n动力系统与区域控制\n电动车逆变器、软件定义汽车\n实时控制、能量回收\n\n\n若遇到 ACU 缩写，可通过上下文判断：涉及服务器性能时可能指 Azure ACU，数据库弹性扩缩容时为 AWS Aurora ACU，汽车动力系统或域控制器则对应英特尔的自适应控制单元。例如某文档提到“ACU 动态分配 vCPU 和内存”，结合云服务背景即可确定为 AWS Aurora 的计算单元定义。\n不同领域的 ACU 虽名称相同，但技术本质差异显著——从硬件电路到云资源抽象，再到汽车控制芯片，体现了“同一缩写、不同技术生态”的典型行业特征。在技术选型时，需特别注意结合具体场景确认其定义，避免概念混淆。\n","categories":["知识库"],"tags":["ai","大模型","ACU","CPU"]},{"title":"怎么做一个交易软件?","url":"/2025/10/23/knows/app/%E6%80%8E%E4%B9%88%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%98%93%E8%BD%AF%E4%BB%B6/","content":"您好！您想利用 OKX 的 API 接口构建一个用于现货和合约交易的量化交易系统，这是一个非常专业且可行的方向。OKX 作为全球领先的加密货币交易所之一，提供了功能强大、文档完善的 API，非常适合进行程序化交易。\n以下是从技术角度出发，为您提供的详细建议和步骤：\n一、 开发前的准备与规划\n明确交易策略 (Strategy Definition)这是最核心的一步。 您需要先想清楚您的交易逻辑。是基于技术指标（如均线、RSI、MACD）的趋势跟踪？还是均值回归（如网格交易）？或是套利策略（期现套利、跨市场套利）？抑或是基于订单簿深度的高频交易？量化您的策略： 将您的交易想法转化为精确的、可执行的数学规则和条件。例如：“当 5 日均线向上穿越 20 日均线，且 RSI &lt; 30 时，买入；当 5 日均线向下穿越 20 日均线时，卖出。”确定交易品种： 专注于哪些币种对（如 BTC&#x2F;USDT, ETH&#x2F;USDT）？是现货、永续合约还是交割合约？\n\n选择编程语言与环境 (Tech Stack)推荐语言： Python 是量化交易领域的绝对主流，因其丰富的库（pandas, numpy, matplotlib, ccxt, requests, websockets）和易学性。其他选择包括 JavaScript&#x2F;Node.js（适合实时性要求高的场景）、C++（追求极致性能）或 Java。开发环境： 推荐使用 Jupyter Notebook 进行策略研究和回测，然后用标准的 IDE（如 PyCharm, VSCode）进行系统开发。\n\n了解 OKX API 文档官方文档是圣经： 务必仔细阅读 OKX API 官方文档。重点关注：REST API: 用于获取市场数据（K 线、深度、最新成交价）、账户信息（余额、持仓）、提交和管理订单。WebSocket API: 用于实时订阅市场数据（如逐笔成交、深度变化、资金费率），这是构建实时交易系统的必备工具，延迟远低于轮询 REST API。API Key 权限： 创建 API Key 时，务必遵循最小权限原则。例如，如果策略只读取数据和下单，就不要赋予提现权限。\n\n\n二、 构建量化交易系统的技术架构一个典型的量化交易系统可以分为以下几个模块：\n\n数据获取模块 (Data Acquisition)历史数据： 使用 REST API 的&#x2F;api&#x2F;v5&#x2F;market&#x2F;candles 等接口获取历史 K 线数据，用于策略回测。实时行情： 使用 WebSocket API 订阅 tickers, books (深度), trades (成交) 等频道，实时获取市场动态。账户数据： 使用 REST API 的&#x2F;api&#x2F;v5&#x2F;account&#x2F;balance 等接口获取账户余额、持仓信息。\n\n策略引擎 (Strategy Engine)这是系统的大脑。它接收来自数据模块的行情和账户信息，根据您预设的交易逻辑进行计算和决策。可以使用 ccxt 库来简化与不同交易所 API 的交互，但直接使用 OKX 官方 API 通常能获得更全面的功能和更低的延迟。\n\n订单执行模块 (Order Execution)当策略引擎发出交易信号后，此模块通过 REST API 的&#x2F;api&#x2F;v5&#x2F;trade&#x2F;order 等接口将订单发送到交易所。关键点：订单类型： 了解市价单（Market）、限价单（Limit）、止盈止损单（Take Profit&#x2F;Stop Loss）、冰山单（Iceberg）等。合约交易： 区分全仓（Cross）和逐仓（Isolated）模式，正确设置杠杆倍数。错误处理： 必须处理网络超时、API 限流、余额不足、价格偏离等异常情况。\n\n风险管理模块 (Risk Management)这是保护您资金的关键！ 量化系统必须内置风控。措施包括：单笔交易风险控制： 限制单笔交易投入的资金比例。最大持仓风险： 设定总仓位上限。强制平仓机制： 监控保证金率，防止爆仓。熔断机制： 当市场出现剧烈波动（如短时间内价格涨跌超过 X%）时，暂停交易。API 调用频率限制： 遵守 OKX 的 API 限流规则，避免被封禁。\n\n回测与模拟盘 (Backtesting &amp; Paper Trading)回测 (Backtesting)： 使用历史数据验证您的策略在过去的表现。注意避免“过拟合”（Overfitting），即策略在历史数据上表现完美，但在实盘中失效。模拟盘 (Paper Trading)： 在实盘交易前，使用模拟资金在真实市场环境中运行您的系统，测试其稳定性和实际表现。OKX 支持模拟盘 API。\n\n\n三、 技术实现要点与建议\n使用合适的库ccxt: 一个强大的加密货币交易库，支持包括 OKX 在内的众多交易所，可以快速开始。requests &#x2F; aiohttp: 用于 HTTP 请求（REST API）。websockets &#x2F; asyncio: 用于建立 WebSocket 连接，处理实时数据流。推荐使用异步编程以提高效率。pandas &#x2F; numpy: 用于数据处理和分析。TA-Lib: 经典的技术分析库。\n\n处理 WebSocket 连接WebSocket 连接需要保持稳定。实现心跳机制（Ping&#x2F;Pong）来维持连接。处理连接中断和重连逻辑。\n\n时间同步确保您的服务器时间与 UTC 时间同步，避免因时间偏差导致订单问题。\n\n安全性API Key 安全： API Key 和 Secret 是您的“密码”，必须妥善保管。不要硬编码在代码中，使用环境变量或配置文件（并设置好文件权限）。服务器安全： 如果部署在云服务器上，确保防火墙配置正确，只开放必要的端口。\n\n日志记录 (Logging)详细记录系统运行日志，包括交易信号、订单状态、错误信息等，便于调试和事后分析。\n\n部署环境本地开发： 用于开发和测试。云服务器： 实盘运行建议使用位于低延迟地区的云服务器（如 AWS, GCP, Azure），以减少网络延迟。\n\n\n四、 OKX 量化交易的优势与注意事项优势：功能全面： 支持现货、多种合约、期权等丰富产品线。API 完善： REST 和 WebSocket API 功能强大，文档清晰。高流动性： 主流交易对深度好，滑点低，有利于大额订单执行。量化工具： 除了 API，OKX 也提供内置的网格、马丁格尔、跟单等策略工具，您可以先使用这些工具熟悉策略，再自行开发。注意事项：API 限流： 严格遵守 API 调用频率限制，否则请求会被拒绝。网络延迟： 对于高频交易，延迟是关键。考虑服务器地理位置。市场风险： 加密货币市场波动剧烈，任何策略都有可能亏损。永远不要投入您无法承受损失的资金。系统风险： 代码 bug、网络故障、交易所 API 故障都可能导致损失。做好充分测试。\n总结构建一个成功的量化交易系统是一个系统工程，需要扎实的编程基础、对市场的理解以及对风险的敬畏。建议您从一个简单的策略开始（如双均线策略），先在模拟盘上运行，逐步完善系统功能和风控措施，待稳定盈利后再投入实盘资金。\n祝您在量化交易的道路上取得成功！\n","categories":["知识库"],"tags":["okx","量化","交易"]},{"title":"什么是张量","url":"/2025/09/12/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%A0%E9%87%8F/","content":"“张量”（Tensor）是一个在数学、物理和人工智能（尤其是深度学习）中非常重要的概念。它的含义在不同领域略有不同，但核心思想一致。\n我们从易到难，逐步解释：\n\n一、通俗理解：张量就是“多维数组”你可以把张量理解为数字的容器，根据维度不同，分为：\n\n\n\n维度\n名称\n例子\n类比\n\n\n\n0 维\n标量（Scalar）\n一个数字，如 5、3.14\n只有大小，没有方向\n\n\n1 维\n向量（Vector）\n[1, 2, 3]\n一列数字，像 Excel 的一列\n\n\n2 维\n矩阵（Matrix）\n[[1,2], [3,4]]\n像 Excel 的表格（行和列）\n\n\n3 维\n3D 张量\n[[[1,2],[3,4]], [[5,6],[7,8]]]\n像一堆矩阵叠在一起\n\n\n4 维及以上\n高维张量\n常用于图像、视频、批量数据\n多层“数据立方体”\n\n\n\n✅ 张量 &#x3D; 多维数组，是标量、向量、矩阵的推广。\n\n\n二、举个生活中的例子 🌰例子 1：一张灰度图片\n大小是 28×28 像素\n每个像素是一个数字（0~255 表示黑白）\n它就是一个 2D 张量：形状为 (28, 28)\n\n例子 2：一张彩色图片（如 RGB）\n大小 28×28，有 3 个颜色通道（红、绿、蓝）\n它是一个 3D 张量：形状为 (28, 28, 3)\n\n例子 3：一批彩色图片（如深度学习中）\n一次处理 32 张 28×28×3 的图片\n这就是一个 4D 张量：形状为 (32, 28, 28, 3)\n第一维：32 张图（批量大小）\n后三维：每张图的结构\n\n\n\n\n三、在深度学习中的作用（如 TensorFlow、PyTorch）在 AI 框架中：\n\n所有数据（图片、文字、音频）都会被转换成张量\n神经网络的输入、输出、权重、梯度……全是张量\n所有计算（加减乘除、卷积、矩阵乘）都是在张量上进行的\n\n\n🔧 例如：你输入一张猫的图片 → 被转成一个 4D 张量 → 经过神经网络层层计算 → 输出一个 1D 张量表示“是猫的概率”\n\n\n四、数学&#x2F;物理中的张量（进阶理解）在物理和微分几何中，张量更强调在坐标变换下保持不变的性质，用于描述：\n\n应力、应变（工程）\n电磁场（物理）\n时空弯曲（广义相对论）\n\n\n⚠️ 这个定义更抽象，涉及“协变”“逆变”等概念，普通用户了解即可。\n\n\n五、关键概念总结\n\n\n术语\n含义\n\n\n\n形状（Shape）\n张量的维度结构，如 (3, 4) 表示 3 行 4 列\n\n\n秩（Rank）\n张量的维度数，如矩阵是秩为 2 的张量\n\n\n数据类型（dtype）\n张量中元素的类型，如 float32、int64\n\n\n\n✅ 总结一句话：\n张量就是“多维数组”，是表示和处理数据的通用工具，从一个数字到图像、视频、批量样本，都可以用张量来表示。\n\n📌 在 AI 时代，你可以说：\n\n“张量是深度学习的血液”，几乎所有计算都围绕它展开。\n\n\n如果你在学习 PyTorch 或 TensorFlow，你会频繁看到：\nimport torchx = torch.tensor([[1, 2], [3, 4]])  # 创建一个 2D 张量print(x.shape)  # 输出: torch.Size([2, 2])\n\n这就是张量的实际使用方式。\n","categories":["知识库"],"tags":["ai","大模型","张量"]},{"title":"什么是AIGC","url":"/2025/09/22/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AFaigc/","content":"AIGC（Artificial Intelligence Generated Content，人工智能生成内容）是继 PGC（专业生产内容）和 UGC（用户生产内容）之后的第三代内容创作范式，通过 AI 算法自动生成文本、图像、音频、视频、3D 模型等多模态内容。其核心在于利用生成对抗网络（GAN）、扩散模型（Diffusion）、大语言模型（LLM）等技术，从数据中学习规律并创造新内容。以下从技术原理、应用场景、争议挑战及未来发展四个维度综合分析：\n\n⚙️ 一、技术原理与核心组件\n生成模型架构\nGAN（生成对抗网络）：通过生成器与判别器的对抗训练生成逼真内容（如图像、音频）。\n扩散模型：从噪声逐步重构数据，生成高质量内容（如 Stable Diffusion、DALL·E）。\nTransformer 与大语言模型（LLM）：基于预训练模型（如 GPT 系列）实现文本创作、代码生成等任务。\n\n\n多模态与跨模态技术\n整合文本、图像、视频等多类型数据，实现跨模态生成（如文生图、文生视频）。\nRAG（检索增强生成）：结合信息检索与生成模型，提升内容准确性与深度。\n\n\n\n\n🌐 二、应用场景与行业变革\n\n\n领域\n典型应用\n案例&#x2F;工具\n\n\n\n内容创作\n自动生成新闻稿、营销文案、短视频脚本\nChatGPT、通义千问\n\n\n设计娱乐\nAI 绘画、3D 建模、游戏角色生成、影视特效\nMidjourney、Sora、Unity AIGC 工具\n\n\n教育医疗\n个性化学习材料生成、医学影像分析报告\nAI 虚拟教师、医疗知识图谱\n\n\n工业与科研\n集成电路设计优化、科研文献摘要生成\nPRIME 深度学习框架\n\n\n数字人服务\n虚拟主播、AI 客服、康养监测（如跌倒报警）\n广州虚拟动力 3D 数字人\n\n\n\n突破性价值：\n\n效率提升：10 分钟生成 1000 条广告文案，成本降低 90%；\n创新赋能：设计师用 AI 生成基础方案，聚焦创意优化。\n\n\n\n️ 三、争议与挑战\n内容真实性风险\n虚假信息泛滥：深度伪造技术生成虚假新闻、视频，扰乱舆论。\n学术伦理争议：多所高校引入 AIGC 查重系统（如四川大学要求 AIGC 率＜ 20%），但手写内容常被误判为 AI 生成。\n\n\n技术局限性\n逻辑缺陷：依赖概率统计生成内容，缺乏因果推理能力（如医疗诊断可能出错）。\n版权归属模糊：AI 生成作品版权界定不清，法律监管滞后。\n\n\n社会影响\n信息过载：低质同质化内容淹没优质信息，用户筛选成本增加。\n就业冲击：部分创意岗位可能被替代（如基础文案、插画师）。\n\n\n\n\n🚀 四、未来发展方向\n技术融合创新\n语义通信（SemCom）：提升无线网络中的 AIGC 传输效率，降低延迟。\n边缘计算部署：在移动端部署轻量化模型（如手机实时生成 3D 内容）。\n\n\n治理与标准化\n中国推行《AIGC 内容标识办法》，要求平台标注“AI 生成合成”标识；\n欧盟《AI 法案》建立伦理框架，规范深度伪造使用。\n\n\n人机协同范式\n认知套利模式：人类聚焦场景化转译与价值审核，AI 负责批量生产；\n教育适配：高校课程融入 AIGC 工具教学（如提示词工程），培养“AI+专业”复合能力。\n\n\n\n\n💎 总结：颠覆性潜力与理性应对AIGC 的本质是生产力工具的革命，其核心价值在于释放人类创造力而非替代人类。当前需平衡三组关系：\n\n效率与质量：利用 AI 提升内容产出规模，同时建立人工审核机制保障深度；\n开放与治理：鼓励技术开源（如 ComfyUI 社区），同步完善法律与伦理规范；\n工具与主体：避免陷入“技术万能”误区，明确“人类决策+AI 执行”的协作边界。\n\n\n行动建议：\n\n开发者：深耕多模态模型优化与垂直场景落地（如工业设计、医疗影像）；\n普通用户：掌握提示词设计、跨工具工作流整合（如 Midjourney+PS 后期）；\n政策制定者：加速数据安全立法，建立 AIGC 内容溯源机制。\n\n\n","categories":["知识库"],"tags":["ai","大模型","AIGC"]},{"title":"什么是MCP","url":"/2025/09/22/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AFmcp/","content":"MCP（Model Context Protocol，模型上下文协议）是 AI 领域的一种开放标准通信协议，由 Anthropic 于 2024 年 11 月率先提出，旨在解决大模型（LLM）与外部工具、数据源交互的标准化问题。其核心价值是通过统一接口打破“信息孤岛”，简化开发流程，实现“即插即用”的 AI 应用扩展。\n以下是关键要点解析：\n\n一、MCP 的核心功能与设计目标\n统一交互标准\n\n传统 AI 工具集成需针对不同 API 编写定制化代码，开发成本高、复用性低（N×M 复杂度）；而 MCP 定义通用协议，使工具与模型的交互标准化（N+M 复杂度），显著降低开发门槛。\n类比说明：\n类似USB-C 接口，统一不同设备的连接方式。\n或像万能遥控器，协调多设备协作（如“观影模式”自动关灯+开投影仪）。\n\n\n\n\n动态扩展能力\n\nMCP 允许模型动态发现并调用新工具：例如新增日历服务时，AI 无需修改代码即可直接调用。\n\n\n\n\n二、核心架构与工作流程MCP 采用客户端-服务器模型，包含三个角色：  \n\n\n\n组件\n功能\n实例\n\n\n\nMCP 主机（Host）\n用户交互界面（如聊天机器人、IDE 插件）\nClaude Desktop、Cursor IDE\n\n\nMCP 客户端（Client）\n集成于主机，管理连接与协议解析\n内嵌于 IDE 的通信模块\n\n\nMCP 服务器（Server）\n提供工具或数据访问的轻量服务（如数据库、API、本地文件）\nGitHub MCP Server、Slack MCP 工具包\n\n\n工作流程：\n\n主机通过客户端发现可用服务器，获取工具描述（名称&#x2F;参数&#x2F;功能）；\n用户提问 → 模型生成标准化调用指令 → 发送至 MCP 服务器；\n服务器执行操作（如查询数据库）→ 返回结果 → 模型生成最终回复。\n\n\n三、实际应用场景与案例\n开发效率提升：\n在 Cursor IDE 中连接 Postgres MCP Server，直接执行 SQL 查询，无需切换工具。\n\n\n智能工作流：\n企业客服系统通过 MCP 整合订单数据库+物流 API，自动回复用户“包裹状态”。\n\n\n多模型协作：\n调用图像生成 MCP 服务器（如 Replicate），为代码项目自动生成界面设计。\n\n\n\n\n四、与其他技术的区别\n\n\n技术\n定位\n与 MCP 的关系\n\n\n\nFunction Calling\n单模型调用的功能模块（如 OpenAI 工具调用）\nMCP 的底层实现基础之一，但仅限单一模型。\n\n\nAI Agent\n能自主决策的智能系统\n依赖 MCP 调用工具完成复杂任务（如决策+执行链）。\n\n\n\n五、当前生态与挑战\n生态进展：\n巨头支持：OpenAI、谷歌、阿里、字节等均宣布兼容 MCP 协议。\n工具市场：高德地图、微信读书等已推出官方 MCP 服务器。\n\n\n现存挑战：\n安全性风险：恶意服务器可通过提示词投毒攻击模型（如强制输出特定内容）。\n协议成熟度：部分开发者认为 MCP“为统一而统一”，实际工具复用率仍待验证。\n\n\n\n\n六、总结MCP 通过标准化协议解决了大模型与外部世界的连接难题，成为 AI Agent 落地的关键技术支撑。其价值在于：✅ 降低开发成本：避免重复编写工具适配代码；✅ 增强模型能力：实时获取外部数据（如天气&#x2F;股票）；✅ 促进生态协同：推动工具服务商与模型厂商开放协作。\n\n注：更多技术细节可参考 MCP 官方文档 或开源项目实践（如 MCP-Demo）。\n\n","categories":["知识库"],"tags":["ai","大模型","MCP"]},{"title":"什么是提示词-学术性回答","url":"/2025/10/28/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%90%E7%A4%BA%E8%AF%8D-%E5%AD%A6%E6%9C%AF%E6%80%A7%E5%9B%9E%E7%AD%94/","content":"“提示词” (Prompt) 在人工智能（AI），特别是生成式 AI（Generative AI）领域，指的是用户提供给 AI 的指令、问题、描述或任何形式的输入信息，用于引导 AI 生成特定的输出内容。\n简单来说，提示词就是你告诉 AI 你想要它做什么的“话”。\n想象一下，你有一个非常有才华但又不完全理解你想法的艺术家（AI）。你想让他画一幅画，你需要详细地告诉他：\n\n主题是什么？ (例如：“一只猫”)\n风格是什么？ (例如：“写实主义风格”，“梵高风格”，“卡通风格”)\n场景是怎样的？ (例如：“坐在窗边”，“在月光下奔跑”)\n颜色要求？ (例如：“温暖的色调”，“蓝色的背景”)\n情绪是什么？ (例如：“快乐的”，“忧郁的”)\n\n你给艺术家的这些描述，就是“提示词”。艺术家收到这些提示词后，就会根据你的要求来创作。\n在 AI 领域，提示词的“艺术家”是各种生成模型，比如：\n\n文本生成模型 (如 ChatGPT, Bard)： 你输入的文字问题、指令，AI 会生成回答、文章、故事、代码等。\n图像生成模型 (如 Midjourney, DALL-E, Stable Diffusion)： 你输入的文字描述，AI 会生成对应的图片。\n音频生成模型： 你输入的文字或音乐风格，AI 会生成语音或音乐。\n视频生成模型： 你输入的文字描述，AI 会生成短视频。\n\n提示词的重要性：\n提示词的质量直接决定了 AI 生成内容的质量和相关性。一个好的提示词能够：\n\n更精确地引导 AI： 告诉 AI 你想要的具体细节，避免生成不相关或不符合要求的内容。\n激发 AI 的创造力： 通过清晰的指令，让 AI 展现其强大的生成能力。\n提高效率： 避免多次尝试和修改，更快地获得满意的结果。\n\n提示词的构成要素（以文本到图像为例）：\n一个完整的提示词可能包含以下部分：\n\n主体 (Subject)： 你想要生成的核心内容。（例如：“一只宇航员猫”）\n动作&#x2F;状态 (Action&#x2F;State)： 主体在做什么。（例如：“漂浮在太空中”）\n背景&#x2F;环境 (Background&#x2F;Environment)： 主体所处的场景。（例如：“背景是星空和地球”）\n风格 (Style)： 艺术风格、画风。（例如：“赛博朋克风格”，“水彩画”，“电影级光照”）\n细节&#x2F;修饰 (Details&#x2F;Modifiers)： 颜色、材质、光照、相机视角等。（例如：“鲜艳的色彩”，“金属质感”，“柔和的光线”，“广角镜头”）\n质量词 (Quality terms)： 强调生成效果。（例如：“高分辨率”，“细节丰富”，“逼真”）\n负面提示词 (Negative Prompt) (部分模型支持)： 告诉 AI 不希望 生成的内容。（例如：“不要模糊”，“不要变形”）\n\n总结：\n提示词就是你和 AI 沟通的语言，是 AI 理解你意图的桥梁。掌握好如何写出有效的提示词，是使用和发挥生成式 AI 能力的关键技能。 随着 AI 技术的发展，如何写出更智能、更有效的提示词（这门学问有时被称为“提示词工程” Prompt Engineering）也变得越来越重要。\n","categories":["知识库"],"tags":["ai","大模型","提示词"]},{"title":"什么是数据集","url":"/2025/07/31/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"什么是数据集“数据集”可以简单理解为为了完成某个机器学习任务而收集在一起的样本集合。对图像分类任务来说，常见的数据集至少包含两大核心部分：\n1、样本（samples）\n图片文件（JPG&#x2F;PNG&#x2F;TIFF&#x2F;…）。有时附带文本、视频、传感器数据等。\n2、标签（labels &#x2F; annotations）\n单标签：一张图对应一个类别，如 downward_dog。多标签：一张图可对应多个标签。框级 &#x2F; 像素级：目标检测、语义分割会给出边界框或掩码（COCO JSON、Pascal VOC XML、PNG mask）。\n","categories":["知识库"],"tags":["ai","大模型","数据集"]},{"title":"什么是训练和推理","url":"/2025/07/24/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86/","content":"什么是训练和推理\n\n\n项目\n含义\n场景\n\n\n\n模型训练（Training）：\n让 AI 学习数据中的规律，调整参数\n需要大量计算资源，一般在电脑或云端完成\n\n\n模型推理（Inference）\n使用训练好的模型对新数据做出预测\n可以部署到手机、平板、IoT 设备等\n\n\npython 训练示例import tensorflow as tf# 加载预训练模型（不需要自己训练）model = tf.keras.applications.MobileNetV2(weights=&#x27;imagenet&#x27;)# 将模型转为 TFLite 格式converter = tf.lite.TFLiteConverter.from_keras_model(model)tflite_model = converter.convert()# 保存为 .tflite 文件with open(&#x27;mobilenet_v2.tflite&#x27;, &#x27;wb&#x27;) as f:    f.write(tflite_model)\n\npython 推理示例注： 要先下载 labels.txt （1000 条记录）\nimport numpy as npfrom PIL import Imageimport tensorflow as tf# 加载 TFLite 模型interpreter = tf.lite.Interpreter(model_path=&quot;mobilenet_v2.tflite&quot;)interpreter.allocate_tensors()# 获取输入输出信息input_details = interpreter.get_input_details()output_details = interpreter.get_output_details()# 准备图片数据def load_image(image_path):    img = Image.open(image_path).convert(&#x27;RGB&#x27;)    img = img.resize((224, 224))    img_array = np.array(img, dtype=np.float32) / 255.0    return np.expand_dims(img_array, axis=0)# 加载并预处理图像image_data = load_image(&quot;test2.jpg&quot;)# 设置输入张量interpreter.set_tensor(input_details[0][&#x27;index&#x27;], image_data)# 运行推理interpreter.invoke()# 获取输出结果output_data = interpreter.get_tensor(output_details[0][&#x27;index&#x27;])# 读取标签文件with open(&quot;labels.txt&quot;, &quot;r&quot;) as f:    labels = [line.strip() for line in f.readlines()]# 打印置信度最高的前 5 个结果top_k = 5top_indices = np.argsort(output_data)[0][-top_k:][::-1]  # 降序排列for i, idx in enumerate(top_indices):    label = labels[idx]    confidence = output_data[0][idx]    print(f&quot;&#123;i+1&#125;. &#123;label&#125;: &#123;confidence:.4f&#125;&quot;)\n\n输出\n\ncurly-coated retriever: 0.8806\nNewfoundland, Newfoundland dog: 0.0108\ngolden retriever: 0.0081\ncocker spaniel, English cocker spaniel, cocker: 0.0053\npug, pug-dog: 0.0044\n\nflutter 推理示例import &#x27;package:tflite_flutter/tflite.dart&#x27;;void loadModel() async &#123;  await Tflite.loadModel(    model: &quot;assets/mobilenet_v2.tflite&quot;,    labels: &quot;assets/labels.txt&quot;,  );&#125;\n","categories":["知识库"],"tags":["ai","大模型"]},{"title":"Dart基础","url":"/2025/05/13/knows/flutter/dart%E5%9F%BA%E7%A1%80/","content":"变量学习1、var 关键字类似于 JavaScript 中的 var，它可以接收任何类型的变量，但最大的不同是 Dart 中 var 变量一旦赋值，类型便会确定，则不能再改变其类型，如：\n// 定义变量var name = &quot;张三&quot;;name = 123; // 报错;\n","categories":["知识库"],"tags":["Flutter","Dart"]},{"title":"adb 常用操作","url":"/2025/05/23/knows/flutter/%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/","content":"列出虚拟设备adb devices\n\n连接虚拟设备,进入 shelladb -s 6c49ee85 shell\n\n保存文件String? html = await webView.getHtml();setState(() &#123;htmlContent = html;&#125;);print(&#x27;Full Page HTML ($&#123;html?.length ?? 0&#125; characters): $html&#x27;);String las = html!.substring(html.length - 1000);print(&quot;last 1000: $las&quot;);final directory = await getApplicationDocumentsDirectory();final filePath = &#x27;$&#123;directory.path&#125;/douyin_html.html&#x27;;// 3. 写入文件await File(filePath).writeAsString(html ?? &#x27;&#x27;);print(&#x27;HTML saved to: $filePath&#x27;);\n\n打印显示 &#x2F;data&#x2F;user&#x2F;0&#x2F;wang.awake.video_fetcher&#x2F;app_flutter&#x2F;douyin_html.html\n用 adb 命令查看文件run-as wang.awake.video_fetcher\n\n会进入到包目录，此时可以查看包\n用 adb 下载虚拟机的文件adb exec-out run-as wang.awake.yidong cat databases/app.db &gt; app.db\n\n这样就将 app.db 下载到了本地\n注意：只有在 root 或 debug 模式下才能用进入到包目录下载文件\n","categories":["知识库"],"tags":["Flutter"]},{"title":"加载assets文件","url":"/2025/05/26/knows/flutter/%E5%8A%A0%E8%BD%BDassets%E6%96%87%E4%BB%B6/","content":"将资源文件加到 assets 目录如 assets&#x2F;key&#x2F;public.pem 文件\n读取资源文件读取前先在 pubspec.yaml 中配置\nflutter:    assets:        - assets/key/public.pem\n\n读取资源文件import &#x27;package:flutter/services.dart&#x27;;String publicKey = await rootBundle.loadString(&#x27;assets/key/public.pem&#x27;);\n","categories":["知识库"],"tags":["Flutter"]},{"title":"Flutter基础组件","url":"/2025/05/12/knows/flutter/%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/","content":"文本组件\nText：用于显示文本。\nRichText：用于显示富文本，支持多种样式。\nDefaultTextStyle：用于设置默认文本样式。\nSelectableText：用于显示可选择的文本。\nFittedBox：用于调整文本大小以适应可用空间。\nTextSpan：用于构建富文本的文本片段。\nTextStyle：用于定义文本的样式，如字体、大小、颜色等。\nTextDecoration：用于定义文本的装饰，如下划线、删除线等。\nTextAlign：用于定义文本的对齐方式，如左对齐、右对齐、居中对齐等。\nTextOverflow：用于定义文本溢出时的处理方式，如截断、省略号等。\nTextDirection：用于定义文本的方向，如左到右、右到左等。\nTextScaleFactor：用于定义文本的缩放因子。\nTextWidthBasis：用于定义文本的宽度基准。\nTextHeightBehavior：用于定义文本的高度行为。\nTextBaseline：用于定义文本的基线。\nTextDecorationStyle：用于定义文本装饰的样式，如实线、虚线等。\nTextDecorationColor：用于定义文本装饰的颜色。\n\n布局组件\nContainer：用于创建一个矩形的容器，用于包裹其他组件。\nPadding：用于在容器内添加内边距，用于调整组件的位置。\nMargin：用于在容器外添加外边距，用于调整组件的位置。\n\nSingleChildScrollView\nSingleChildScrollView：用于创建一个单子滚动视图，用于包裹其他组件。\n\n简介SingleChildScrollView 是 Flutter 中的滚动组件。其作用是包裹子组件，当子组件内容超过屏幕可视区域时，允许用户通过滚动查看完整内容。\n当前代码中， SingleChildScrollView 作为 Scaffold 的 body 属性值，内部通过 Padding 和 Column 布局容纳其他子控件（如 TextField 等），确保页面内容超出屏幕时可滚动浏览。\n\nListView：用于创建一个列表视图，用于包裹其他组件。\nGridView：用于创建一个网格视图，用于包裹其他组件。\nStack：用于创建一个堆叠视图，用于包裹其他组件。\nPositioned：用于创建一个可定位的组件，用于调整组件的位置。\n\n交互组件\nGestureDetector：用于检测用户的手势，如点击、长按、滑动等。\nInkWell：用于创建一个可点击的 ink 效果，用于响应用户的手势。\nDraggable：用于创建可拖动的组件。\nDropTarget：用于创建可接收拖动组件的目标。\nDragTarget：用于创建可接收拖动组件的目标。\nDragSource：用于创建可拖动的组件。\nDragSourceListener：用于监听拖动组件的状态。\nDropTargetListener：用于监听接收拖动组件的状态。\nDragTargetAcceptor：用于接受拖动组件的目标。\nDragTargetAcceptorListener：用于监听接收拖动组件的状态。\nDragTargetAcceptorDelegate：用于定义接收拖动组件的目标的行为。\nDragTargetAcceptorDelegateListener：用于监听接收拖动组件的状态。\nDragTargetAcceptorDelegateBuilder：用于构建接收拖动组件的目标的行为。\n\n动画组件\nAnimatedContainer：用于创建一个可动画的容器，用于调整组件的位置、大小、颜色等。\nAnimatedOpacity：用于创建一个可动画的透明度，用于调整组件的透明度。\nAnimatedPositioned：用于创建一个可动画的位置，用于调整组件的位置。\nAnimatedPadding：用于创建一个可动画的内边距，用于调整组件的位置。\nAnimatedMargin：用于创建一个可动画的外边距，用于调整组件的位置。\nAnimatedSize：用于创建一个可动画的大小，用于调整组件的大小。\nAnimatedAlign：用于创建一个可动画的对齐方式，用于调整组件的位置。\n\n弹窗组件\nAlertDialog：用于创建一个对话框，用于显示提示信息。\nSimpleDialog：用于创建一个简单的对话框，用于显示提示信息。\nBottomSheet：用于创建一个底部弹出的对话框，用于显示提示信息。\nDialog：用于创建一个对话框，用于显示提示信息。\nSnackBar：用于创建一个弹出的提示信息，用于显示提示信息。\nBottomAppBar：用于创建一个底部弹出的对话框，用于显示提示信息。\nBottomNavigationBar：用于创建一个底部导航栏，用于显示提示信息。\nBottomNavigationBarItem：用于创建一个底部导航栏的条目，用于显示提示信息。\n\n","categories":["知识库"],"tags":["Flutter"]},{"title":"Flutter基础组件","url":"/2025/05/30/knows/flutter/%E5%B8%B8%E7%94%A8%E7%B1%BB/","content":"Completer其作用是创建 Future 对象，并且能手动控制该对象的完成状态 1 。借助 Completer，开发者能够在异步操作完成后，将结果传递给对应的 Future 对象，这样依赖该 Future 的代码就可以继续执行。\n下面是一个简单的示例代码，展示了如何使用 Completer：\nimport &#x27;dart:async&#x27;;void main() &#123;  // 创建一个 Completer 对象  Completer&lt;String&gt; completer = Completer&lt;String&gt;();  // 获取 Completer 关联的 Future 对象  Future&lt;String&gt; future = completer.future;  // 为 Future 对象添加回调函数  future.then((value) &#123;    print(&#x27;Future 完成，结果是: $value&#x27;);  &#125;);  // 模拟异步操作  Future.delayed(Duration(seconds: 2), () &#123;    // 完成 Completer，并传递结果    completer.complete(&#x27;操作完成&#x27;);  &#125;);&#125;\n\n在这个示例中，我们创建了一个 Completer 对象，获取其关联的 Future 对象，并为该 Future 添加了一个回调函数。接着模拟了一个异步操作，在操作完成后调用 completer.complete 方法，将结果传递给 Future ，触发回调函数的执行。\n","categories":["知识库"],"tags":["Flutter"]},{"title":"常见目录","url":"/2025/07/02/knows/flutter/%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95/","content":"常见目录Android 标准目录说明：DCIM - 所有 Android 设备都有，相机默认存储目录Pictures - 大部分设备有，但不是强制要求Movies - 部分设备有，用于存储视频Download - 所有设备都有，下载目录\nIOS 标准目录说明：iOS 没有传统的文件目录结构，使用相册概念relativePath 在 iOS 上是相册名称，不是文件路径权限管理更严格，需要专门的照片库权限iOS 14+ 引入了有限权限模式自定义相册创建失败时，应该有备用策略（保存到默认相册）沙盒机制限制，只能通过系统 API 访问照片库这就是为什么我们在处理 iOS 时需要与 Android 完全不同的策略！\n应用沙盒应用沙盒&#x2F;├── Documents&#x2F; # 用户文档，会被 iTunes 备份├── Library&#x2F;│ ├── Caches&#x2F; # 缓存文件，系统可能清理│ └── Preferences&#x2F; # 应用偏好设置├── tmp&#x2F; # 临时文件，系统会定期清理└── SystemData&#x2F; # 系统数据（iOS 14+）\n照片相册类型&#x2F;&#x2F; 系统预置相册（不能删除）‘Camera Roll’ &#x2F;&#x2F; 相机胶卷（主相册）‘Favorites’ &#x2F;&#x2F; 收藏‘Recently Added’ &#x2F;&#x2F; 最近添加‘Screenshots’ &#x2F;&#x2F; 屏幕截图‘Selfies’ &#x2F;&#x2F; 自拍‘Live Photos’ &#x2F;&#x2F; Live 照片‘Portrait’ &#x2F;&#x2F; 人像‘Panoramas’ &#x2F;&#x2F; 全景‘Videos’ &#x2F;&#x2F; 视频‘Slo-mo’ &#x2F;&#x2F; 慢动作‘Time-lapse’ &#x2F;&#x2F; 延时摄影‘Bursts’ &#x2F;&#x2F; 连拍‘Recently Deleted’ &#x2F;&#x2F; 最近删除\n应用// 创建/保存到自定义相册final result = await PhotoManager.editor.saveImage(  imageBytes,  filename: fileName,  title: fileName,  relativePath: &#x27;易动收藏&#x27;, // 相册名称，不是路径);\n","categories":["知识库"],"tags":["Flutter"]},{"title":"模拟器相关","url":"/2025/07/25/knows/flutter/%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9B%B8%E5%85%B3/","content":"模拟长按动作\n使用鼠标模拟「长按」操作步骤：\n\n在模拟器中打开包含图片的应用（如 Safari 或你的 Flutter 应用）。将鼠标悬停在图片上。按住鼠标左键不放（保持 1-2 秒），模拟器会自动触发长按事件。如果出现菜单（如保存图片选项），直接选择即可。替代方案（更可靠）：\nControl + 点击图片（Mac）或 右键点击图片（Windows），直接弹出上下文菜单（如保存图片）。\n","categories":["知识库"],"tags":["ios模拟器"]},{"title":"虚拟机相关","url":"/2025/05/30/knows/flutter/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/","content":"手动启动虚拟机1. 列出虚拟机# 列出所有已创建的虚拟设备emulator -list-avds# 或者使用 avdmanageravdmanager list avd\n\n2. 启动虚拟机# 基本启动emulator -avd [AVD名称]# 后台启动（不阻塞命令行）emulator -avd [AVD名称] &amp;# Windows 后台启动start emulator -avd [AVD名称]# 指定分辨率启动emulator -avd [AVD名称] -skin 1080x1920# 冷启动（清除状态）emulator -avd [AVD名称] -wipe-data# 无声启动emulator -avd [AVD名称] -no-audio# 显示详细日志emulator -avd [AVD名称] -verbose\n\n3.性能相关# 启用硬件加速emulator -avd [AVD名称] -gpu host# 分配更多内存emulator -avd [AVD名称] -memory 2048# 启用多核支持emulator -avd [AVD名称] -cores 4# 启用快速启动emulator -avd [AVD名称] -no-snapshot-save\n","categories":["知识库"],"tags":["Flutter"]},{"title":"视频播放测试地址","url":"/2025/05/20/knows/flutter/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80/","content":"最近在开发视频播放相关的业务功能，开发测试时，需要涉及到 MP4、M3U8 等视频格式。我每次找测试视频地址时，都要找很久，现在把我在网上收集到的 MP4、M3U8 格式视频地址放在这里，希望帮助到正在进行视频播放开发的你。\nMP4 格式海洋：http://vjs.zencdn.net/v/oceans.mp4\n西瓜视频 Demo：https://sf1-cdn-tos.huoshanstatic.com/obj/media-fe/xgplayer_doc_video/mp4/xgplayer-demo-360p.mp4\n大兔子：http://www.w3school.com.cn/example/html5/mov_bbb.mp4\n大灰熊：https://www.w3schools.com/html/movie.mp4\n冰川：https://media.w3.org/2010/05/sintel/trailer.mp4\n新闻视频 1：https://stream7.iqilu.com/10339/upload_transcode/202002/09/20200209105011F0zPoYzHry.mp4\n新闻视频 2：https://stream7.iqilu.com/10339/upload_transcode/202002/09/20200209104902N3v5Vpxuvb.mp4\nM3U8 格式西瓜播放器 Demo：https://sf1-cdn-tos.huoshanstatic.com/obj/media-fe/xgplayer_doc_video/hls/xgplayer-demo.m3u8\n大白兔：https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8\n","categories":["知识库"],"tags":["Flutter","视频"]},{"title":"打包配置sha1","url":"/2025/05/26/knows/flutter/%E9%85%8D%E7%BD%AEsha1/","content":"主要参考：https://juejin.cn/post/7129495755207180319\n生成 key 目录mkdir ~/dapp/keys/\n\n生成私钥keytool -genkey -v -keystore ~/dapp/keys/prod_key.jks -keyalg RSA -keysize 2048 -validity 100000 -alias prod_key\n\nlocal.properties 添加上述设置storePassword = xxxxxxkeyPassword = xxxxxxkeyAlias = prod_keystoreFile = /xxxx/xxxx/dapp/keys/prod_key.jks\n\n到项目下的 android&#x2F;app&#x2F;build.gradle 中添加import java.util.Properties...android &#123;    signingConfigs &#123;        create(&quot;release&quot;) &#123;            // 加载 local.properties 文件            val localProperties = Properties().apply &#123;                load(rootProject.file(&quot;local.properties&quot;).inputStream())            &#125;            // 读取配置项            storeFile = file(localProperties.getProperty(&quot;storeFile&quot;))            storePassword = localProperties.getProperty(&quot;storePassword&quot;)            keyAlias = localProperties.getProperty(&quot;keyAlias&quot;)            keyPassword = localProperties.getProperty(&quot;keyPassword&quot;)        &#125;    &#125;    buildTypes &#123;        release &#123;            signingConfig = signingConfigs.getByName(&quot;release&quot;)        &#125;        debug &#123;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)        &#125;    &#125;&#125;\n\n测试签名./gradlew signingReport\n\n打包flutter build apk --release\n","categories":["知识库"],"tags":["Flutter"]},{"title":"什么是提示词（用直白的语言）","url":"/2025/10/28/knows/ai/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%90%E7%A4%BA%E8%AF%8D/","content":"好的，我们用大家都能明白的“生活化”的比喻来解释“提示词”是什么。\n想象一下，你有一个特别能干但又有点“呆萌”的机器人助手。这个助手什么都会，比如写文章、画画、唱歌、回答问题，但是它有个特点：你得把事情说得明明白白，它才能做得好。\n这个“说得明明白白”的过程，就是“提示词”。\n我们来举几个例子：\n1. 机器人写作文（类比 ChatGPT）\n\n不好的提示词： “写个作文。”\n\n（机器人很茫然，写什么？关于什么的？给谁看的？）\n\n\n好一点的提示词： “写一篇关于秋天的作文。”\n\n（机器人有点明白了，写秋天，但还是不知道具体写什么内容，多长，什么风格。）\n\n\n最好的提示词： “我想写一篇给孙子听的作文，讲讲小时候我过中秋节的故事，要温馨一点，大概五百字左右。”\n\n分析：\n\n“写一篇作文”：明确了要干什么。\n“给孙子听的”：说明了受众和语气，要简单、有趣、温情。\n“讲讲小时候我过中秋节的故事”：这是核心内容，告诉了故事的主题和背景。\n“要温馨一点”：这是风格和情感要求。\n“大概五百字左右”：这是长度要求。\n\n\n这个“最好的提示词”，就像你跟儿女说：“帮我给孙子写封信，写写小时候过中秋的趣事，让他知道爷爷奶奶年轻时候也很快乐，字数不用太多，大概让他看懂就行。”\n\n\n\n\n2. 机器人画画（类比 Midjourney, DALL-E）\n\n不好的提示词： “画个画。”\n\n（机器人不知道画啥，什么风格？）\n\n\n好一点的提示词： “画一只猫。”\n\n（好，但猫长啥样？在干嘛？什么背景？）\n\n\n最好的提示词： “帮我画一幅画，就画我那只老花猫，趴在暖暖的阳台上晒太阳，旁边放着一个小鱼缸，整体色调要像国画一样淡雅，看起来很舒服。”\n\n分析：\n\n“帮我画一幅画”：明确了目的。\n“就画我那只老花猫”：指定了具体的主角，有感情色彩。\n“趴在暖暖的阳台上晒太阳”：描述了动作和场景。\n“旁边放着一个小鱼缸”：增加了细节。\n“整体色调要像国画一样淡雅，看起来很舒服”：这是风格和整体感受的要求。\n\n\n这个“最好的提示词”，就像你跟会画画的孙子说：“小孙子，你帮奶奶画一张咱家大花猫懒洋洋晒太阳的样子，旁边再画个养金鱼的小缸，颜色别太鲜艳，就像奶奶喜欢的那种中国画，看了就觉得心里特别踏实。”\n\n\n\n\n总结一下：\n“提示词”就像是跟一个万能助手沟通的“说明书”或“吩咐”。\n\n说明书要写清楚： 你想要什么？（主题）\n说明书要写详细： 它的样子、动作、环境、风格、感觉是怎么样的？（细节、风格、情感）\n说明书越详细，机器人（AI）就越能明白你的意思，做出来的东西就越让你满意。\n\n所以，当你和 AI 说话的时候，不要只说“我想……”，而是要说得像跟一位很有耐心的朋友解释一样，把你想到的、看到的、感觉到的，都尽可能地告诉它。你给的“提示词”越具体、越生动，AI 给你的“回答”就越贴心、越符合你的心意。\n","categories":["知识库"],"tags":["ai","大模型","提示词"]},{"title":"姿势识别","url":"/2025/07/25/knows/ai/%E5%A7%BF%E5%8A%BF%E8%AF%86%E5%88%AB/","content":"这是一个非常有意义的项目！坐姿识别 App 可以帮助孩子养成良好的学习习惯，预防脊柱侧弯、近视等问题。以下是为你量身定制的 完整开发方案设计，包括功能模块、技术选型、用户交互设计和盈利模式建议。\n\n🎯 一、产品定位\n\n\n名称\n示例\n\n\n\n应用名称\n“姿势守护” &#x2F; “坐得正” &#x2F; “小树苗坐姿助手”\n\n\n目标用户\n6-12 岁小学生及家长\n\n\n核心功能\n实时识别坐姿是否正确，提供提醒与纠正建议\n\n\n使用场景\n写作业、上网课、阅读、使用平板等\n\n\n\n🧠 二、核心功能模块设计1. ✅ 坐姿识别（AI 视频分析）技术实现：\n使用 摄像头实时采集画面\n使用 姿态估计模型（如 MediaPipe Pose 或 OpenPose）识别关键点\n判断是否符合标准坐姿（背部挺直、双脚平放、眼睛与书本距离合理等）\n\n输出判断指标：\n头部是否前倾\n背部是否弯曲\n手臂是否自然下垂\n眼睛与屏幕&#x2F;书本的距离是否合理\n\n提示方式：\n音频提示：“你的姿势不太对哦~”\n图形化反馈：绿色表示正确，红色表示错误\n每次错误后给予一次指导动画或语音说明\n\n\n2. ✅ 学习时间管理功能说明：\n设置每次学习时长（例如 30 分钟）\n自动记录学习时间和坐姿正确率\n提供休息提醒（每 45 分钟提醒活动身体）\n\n数据展示：\n每日坐姿得分\n每周进步趋势图\n孩子的学习报告（可导出 PDF 或分享给家长）\n\n\n3. ✅ 游戏化激励机制设计思路：\n通过积分、勋章、虚拟宠物等方式激励孩子持续使用\n每次坐姿正确即可获得“健康币”，用于解锁新角色或皮肤\n家长端可以看到孩子的成长数据并给予奖励\n\n\n4. ✅ 家长控制面板功能说明：\n查看孩子坐姿历史记录\n设置允许使用时间段（防沉迷）\n接收异常坐姿提醒通知\n导出学习报告（PDF&#x2F;Excel）\n\n\n5. ✅ AR 姿势教学（进阶功能）功能说明：\n通过 AR 模拟正确坐姿\n孩子可以对着镜子模仿\n提供语音引导和动作评分\n\n\n🔧 三、技术选型建议\n\n\n模块\n技术栈\n说明\n\n\n\nApp 开发\nFlutter（Dart）\n跨平台（iOS + Android），开发效率高\n\n\nAI 姿态识别\nMediaPipe Pose &#x2F; TensorFlow Lite\n轻量级模型，适合移动端部署\n\n\n数据存储\nFirebase &#x2F; SQLite\n用户数据本地+云端同步\n\n\n图像处理\nOpenCV &#x2F; Dart 的 image 库\n用于预处理和图像增强\n\n\n推送通知\nFirebase Cloud Messaging (FCM)\n给家长发送提醒\n\n\n\n🖥️ 四、UI&#x2F;UX 设计建议\n\n\n元素\n设计建议\n\n\n\n主界面\n简洁可爱风格，适合儿童审美\n\n\n提醒图标\n使用卡通形象或动物表情包吸引注意力\n\n\n进度条\n用颜色变化显示坐姿状态\n\n\n成就系统\n使用徽章、金币、虚拟宠物等方式激励\n\n\n家长端\n更加简洁专业，突出数据分析和设置功能\n\n\n\n💰 五、商业模式建议\n\n\n方式\n说明\n\n\n\n免费下载 + 内购\n提供基础功能免费，高级功能内购（如 AR 教学、个性化提醒）\n\n\n订阅制会员\n每月&#x2F;年付费解锁更多内容和功能\n\n\nB2B 合作\n与学校合作，批量采购作为课堂辅助工具\n\n\n广告变现\n为教育类品牌做精准投放（如文具、护眼灯）\n\n\n\n🚀 六、开发阶段规划（敏捷开发）\n\n\n阶段\n时间\n目标\n\n\n\nPhase 1（需求 &amp; UI）\n1-2 周\n确定功能清单，设计原型\n\n\nPhase 2（姿态识别 MVP）\n2-3 周\n实现基本 AI 姿态检测\n\n\nPhase 3（App 功能集成）\n3-4 周\n整合 UI 和 AI，完成核心功能\n\n\nPhase 4（测试 &amp; 上架）\n1-2 周\n测试优化，上架应用商店\n\n\nPhase 5（迭代 &amp; 商业化）\n持续进行\n收集用户反馈，推出付费功能\n\n\n\n🤝 七、我可以帮你做什么？\n✅ 提供完整的代码模板（Flutter + TFLite 姿态识别）\n✅ 教你如何训练和部署自己的姿态识别模型\n✅ 教你如何接入 Firebase 实现数据统计和推送通知\n✅ 提供 UI&#x2F;UX 设计参考图和资源推荐\n✅ 教你如何申请 App Store &#x2F; Google Play 上架\n\n\n🚀 如果你现在就想开始告诉我你想做的第一个功能，比如：\n\n“我想先做一个简单的坐姿识别器”\n“我想做一个带 AR 教学的版本”\n“我想做一个面向学校的 B2B 解决方案”\n\n我会立即给你一份详细的开发指南和代码 😊\n","categories":["知识库"],"tags":["ai","大模型"]},{"title":"git必学命令","url":"/2025/07/23/knows/git/git%E5%BF%85%E5%AD%A6%E5%91%BD%E4%BB%A4/","content":"git 必学命令git reset –hardgit reset –hard 是 Git 中一个非常强大但也需要谨慎使用的命令。它用于将工作目录和暂存区（index）都重置到某个提交（commit）的状态，丢弃所有未提交的更改。\n🚨 使用前请注意：–hard 选项会永久删除当前工作目录中未提交的修改！所以在使用这个命令之前，请确保你已经保存了重要的更改，或者确认这些更改可以被丢弃。✅ 命令格式\ngit reset --hard [commit]\n\n参数说明：参数 含义–hard 将工作目录、暂存区、HEAD 都重置为指定 commit 的状态[commit] 指定要回退到的提交，如 HEAD~1、abc1234 等。如果省略，默认是 HEAD✅ 示例用法\n\n回退到最后一次提交（放弃所有本地修改）\n\ngit reset --hard HEAD\n\n作用：丢弃所有未提交的更改（包括暂存区和工作区），回到上一次提交的状态。\n\n回退到上一个提交（撤销最后一次提交）\n\ngit reset --hard HEAD~1\n\n作用：将分支指针移动到上一个提交，并清空工作区和暂存区的内容。\n\n回退到某个具体的提交哈希值\n\ngit reset --hard abc1234567890abcdef\n\n作用：将工作目录恢复到 abc1234… 提交时的状态。\n🔄 git reset 的三种模式对比全屏复制模式 作用–soft 仅移动 HEAD 指针，保留暂存区和工作区的更改–mixed（默认） 移动 HEAD 和暂存区，但保留工作区的更改（适合撤销 add 但保留修改）–hard 移动 HEAD、暂存区、工作区，完全丢弃未提交的更改（最彻底的回退）🛠️ 实际应用场景全屏复制场景 推荐命令撤销最近一次提交 git reset –hard HEAD~1弃掉本地所有未提交的修改 git reset –hard HEAD从远程拉取后强制同步 git fetch origin &amp;&amp; git reset –hard origin&#x2F;branch-name⚠️ 注意事项如果你正在开发中，且有未提交的代码，执行 git reset –hard 会永久丢失这些更改。如果你想保留修改但不想提交，可以使用 git stash 来临时保存。🧩 补充：查看历史提交如果你不确定要回退到哪个提交，可以先查看提交历史：\ngit log --oneline\n\n输出示例：\nabc1234 (HEAD -&gt; main) Add new featuredef5678 Fix bug in loginghi90ab Initial commit你可以选择其中一个 commit 哈希来执行 reset。\n✅ 总结命令 效果git reset –hard 弃掉所有未提交的更改，回到上次提交的状态git reset –hard HEAD~1 撤销最后一次提交，并清除所有修改git reset –hard  将工作目录恢复到指定提交的状态如果你还有关于 git revert 或 git checkout 的问题，也可以问我 😊\nreset 命令命令 描述git reset –soft HEAD1 撤销最后一次提交，保留修改在暂存区git reset –mixed HEAD1 撤销最后一次提交，保留修改在工作区（默认）git reset –hard HEAD~1 彻底回退到上一次提交，丢弃所有未提交的更改git stash 暂存当前工作区的更改git stash apply 应用最近一次暂存的更改git revert [commit] 反向提交，安全地撤销某次提交（不会丢失历史）\n日常开发常用组合git checkout -b feature/new-feature       # 创建并切换分支# 修改代码...git add .                                  # 添加更改git commit -m &quot;Add new feature&quot;            # 提交更改git push origin feature/new-feature        # 推送到远程\n\ngit push –set-upstream origin xxx 的意思这个–set-upstream 表示设置当前分支的远程分支，指定关联，以后每次 git push 的时候，会自动推送到远程这个 xxx 分支否则要指定 git push origin xxx\n","categories":["知识库"],"tags":["git"]},{"title":"Flutter配置相关","url":"/2025/05/20/knows/flutter/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/","content":"配置 Java 环境1、安装 Java\nbrew install openjdk@21\n\n2、配置环境变量写进.bash_profile\nexport JAVA_HOME=/opt/homebrew/opt/openjdk@21export PATH=$JAVA_HOME/bin:$PATH\n\n3、验证\njava -version\n\n注意：gradle 版本与 java 版本要匹配https://docs.gradle.org/current/userguide/compatibility.html#java\n换源build.gradle.kts\nallprojects &#123;    repositories &#123;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;        maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;    &#125;&#125;\n\nsettings.gradle.kts\nrepositories &#123;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;&#125;\n\nbuild.gradle.kts 文件中的仓库配置是用于项目所有模块的全局配置，而 settings.gradle.kts 中的配置是用于插件管理的。在 Gradle 项目中，通常需要在这两个地方都配置仓库地址，以确保所有依赖项都能正确下载。建议将 build.gradle.kts 中的仓库配置也替换为阿里云镜像源，以保持一致性并提高构建速度。\n出错\nWhat went wrong:Plugin [id: ‘com.android.application’, version: ‘8.7.0’, apply: false] was not found in any of the following sources:\n\n\nGradle Core Plugins (plugin is not in ‘org.gradle’ namespace)\nIncluded Builds (No included builds contain this plugin)\nPlugin Repositories (could not resolve plugin artifact ‘com.android.application:com.android.application.gradle.plugin:8.7.0’)Searched in the following repositories:maven(https://maven.aliyun.com/repository/public)maven2(https://maven.aliyun.com/repository/google)maven3(https://maven.aliyun.com/repository/gradle-plugin)\n\n错误信息显示无法找到 com.android.application 插件，这是因为阿里云镜像可能没有完全同步 Google 的仓库内容。建议在 settings.gradle.kts 中保留 Google 的官方仓库，同时使用阿里云镜像。以下是修改后的配置：\nrepositories &#123;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/public&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/google&quot;) &#125;    maven &#123; setUrl(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) &#125;    google()    mavenCentral()&#125;\n\n查看 Android 模拟器版本号的两种方法：1、ADB 查看\nadb shell getprop ro.build.version.releaseadb shell getprop ro.build.version.sdk\n\n第一条命令输出 Android 系统版本（如 13），第二条输出 API 级别（如 33）\n2、在模拟器界面查看\n\n打开模拟器\n进入 Settings → System → About phone → Android version\n连续点击 “Build number” 7 次可解锁开发者选项\n\nAndroid 存储权限变更&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;\n\n如果 ios 目录被删除，应该怎么办？flutter create --platform ios .\n\n这样会在当前目录下生成一个新的 ios 目录，其中包含了 Flutter 所需的所有文件和配置。\n","categories":["知识库"],"tags":["Flutter","Java"]},{"title":"git问题解决","url":"/2025/05/16/knows/git/git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"git 问题解决\ngit push –set-upstream origin master\nPlease contact your system administrator.\nAdd correct host key in &#x2F;Users&#x2F;xxx&#x2F;.ssh&#x2F;known_hosts to get rid of this message.\nOffending RSA key in &#x2F;Users&#x2F;xxx&#x2F;.ssh&#x2F;known_hosts:3\nHost key for github.com has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n\n应该怎么处理\n这个问题是在执行 git push 命令时，因远程主机密钥更改导致的主机密钥验证失败。以下是几种处理方法：\n1、手动删除错误密钥可以使用以下命令删除 known_hosts 文件中错误的密钥：\n2、使用 ssh-keygen 重新生成密钥 或 将 SSH 密钥添加到 GitHub 账户生成新密钥ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;\n\n将 SSH 密钥添加到 GitHub 账户cat ~/.ssh/id_ed25519.pub\n\n3、测试连接ssh -T git@github.com\n","categories":["知识库"],"tags":["git"]},{"title":"误添加的文件，怎么删除","url":"/2025/05/16/knows/git/%E8%AF%AF%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%96%87%E4%BB%B6/","content":"误添加的文件，怎么删除将 .env 配置文件添加到了 git 仓库上，因为里面有重要的配置信息，所以需要删除。\n\n先将.env 文件从 git 仓库中删除\n\ngit rm --cached .env\n\n\n推送一次\n\ngit commit -m &quot;Remove .env file from repository&quot;git push origin main\n","categories":["知识库"],"tags":["git"]},{"title":"npm相关","url":"/2025/07/02/knows/node&js/npm%E7%9B%B8%E5%85%B3/","content":"项目运行在 node 18 下出错16 下正常，但 18 下出错\n用18会提示node:internal/crypto/hash:67this[kHandle] = new _Hash(algorithm, xofLen);^Error: error:0308010C:digital envelope routines::unsupportedat new Hash (node:internal/crypto/hash:67:19)at Object.createHash (node:crypto:133:10)at BulkUpdateDecorator.hashFactory (/Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:184161:18)at BulkUpdateDecorator.update (/Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:184062:50)at /Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:107101:9at /Users/lyq89566/prod/prodweb/ucaptain-fe/node_modules/@umijs/deps/compiled/webpack/5/bundle5.js:33829:16at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;opensslErrorStack: [ &#x27;error:03000086:digital envelope routines::initialization error&#x27; ],library: &#x27;digital envelope routines&#x27;,reason: &#x27;unsupported&#x27;,code: &#x27;ERR_OSSL_EVP_UNSUPPORTED&#x27;&#125;Node.js v18.0.0\n\n可以在命令行下直接运行\nexport NODE_OPTIONS=&quot;--openssl-legacy-provider --max-old-space-size=8192&quot;npm run dev\n\n在.env.local 下运行\nNODE_OPTIONS=--openssl-legacy-provider --max-old-space-size=8192\n","categories":["知识库"],"tags":["npm"]},{"title":"什么是敞口","url":"/2025/09/17/knows/%E7%BB%8F%E6%B5%8E/%E4%BB%80%E4%B9%88%E5%8F%AB%E6%95%9E%E5%8F%A3/","content":"“敞口”是一个在金融领域非常常用的术语，英文对应的是 Exposure。\n简单来说，“敞口”指的是你（或你的投资组合）在某个特定风险因素面前暴露的程度，也就是你可能因此遭受损失或获得收益的“风险&#x2F;机会规模”。\n你可以把它理解为 “风险暴露” 或 “风险暴露头寸”。\n\n🌰 举个通俗的例子：假设你买了 100 股腾讯的股票，每股 500 元，总共投入 5 万元。\n\n你的“腾讯股票敞口”就是 5 万元。\n这意味着：腾讯股价每上涨 1%，你赚 500 元；每下跌 1%，你就亏 500 元。\n你在这 5 万元上，完全“暴露”在腾讯股价波动的风险（和机会）之下。\n\n\n🔍 常见的“敞口”类型：\n\n\n敞口类型\n含义\n例子\n\n\n\n市场敞口\n对整体市场波动的风险暴露\n你持有 A 股，就对 A 股市场有敞口\n\n\n行业敞口\n对某个行业的风险暴露\n你重仓新能源车股票，就对新能源行业有高敞口\n\n\n个股敞口\n对某一只股票的风险暴露\n你持有大量茅台股票，茅台就是你的“个股敞口”\n\n\n货币敞口\n对汇率波动的风险暴露\n你投资了美股，就对美元&#x2F;人民币汇率有敞口\n\n\n利率敞口\n对利率变化的风险暴露\n银行放贷多，就对利率下行有敞口（利息收入减少）\n\n\n信用敞口\n对借款人违约的风险暴露\n银行借给某公司 1 亿，这 1 亿就是信用敞口\n\n\n\n📌 在之前关于 NVDY ETF 的讨论中，“敞口”是什么意思？我们说 NVDY “复制英伟达的敞口”，意思是：\n\nNVDY 虽然不直接买英伟达的股票，但它通过期货、期权等工具，让自己基金的表现尽可能地跟随英伟达股价的涨跌。也就是说，投资者通过买 NVDY，就“暴露”在了英伟达股价波动的风险和机会中——这就是获得了“英伟达的敞口”。\n\n\n✅ 总结一句话：\n“敞口”就是你“押了多少钱”在某个风险上。敞口越大，潜在的收益和亏损空间就越大。\n\n理解“敞口”有助于你评估投资组合的风险集中度，避免把所有鸡蛋放在一个篮子里。\n","categories":["知识库"],"tags":["投资","股票","敞口"]},{"title":"禅的世界-圣严法师","url":"/2025/05/12/books/%E4%BD%9B%E5%AD%A6/%E7%A6%85%E7%9A%84%E4%B8%96%E7%95%8C/","content":"禅的世界-圣严法师\n释圣严，或尊称为圣严“法师”（1931年1月22日－2009年2月3日），俗名张保康，江苏南通人，佛学“大师”，教育家，佛教“弘法大师”，日本立正大学博士，也是禅宗曹洞宗的第五十代传人、临济宗的第五十七代传人、台湾法鼓山的创办人，法鼓山的弟子信众尊称为“师父”。\n\n禪的世界 - 聖嚴法師.pdf (访问密码: 5098)\n","categories":["佛学"]},{"title":"字里藏医","url":"/2025/05/13/books/zhongyi/%E5%AD%97%E9%87%8C%E8%97%8F%E5%8C%BB/","content":"\n《字里藏医》是2007年安徽教育出版社出版的图书，作者是徐文兵。该书深入浅出地介绍了中医词汇的古今之别，以帮助读者了解中医的基本知识。\n\n内容简介几千年来，我们使用的都是同样的文字，但表达的意思可能已经不同了。很多字词已经渐渐失去了它们的原意。在多数情况下，这并不会造成什么困扰，但对中医这门古老学问就不同了，它需要我们唤醒那些沉睡的文字的原意。在现代语境下，在涉外教学看病过程中，徐文兵大夫随时会遭遇熟悉字词的陌生化情形。比如说“思想”，思和想有什么区别？又比如“魂魄”，魂是什么，魄是什么？“肥”与“胖”的区别？“皮”与“肤”是一回事吗？    要研究中医，发皇古意，就必须先从最基本的词汇入手，正义严辞。《字里藏医》就是这样一本以深入浅出的文字厘清中医最基本的词汇，恢复中医本来面目的启蒙书。\n下载地址字里藏医.txt (访问密码: 5098)\n","categories":["中医"],"tags":["徐文兵"]},{"title":"celery 使用","url":"/2025/06/11/knows/python/celery/","content":"celery 使用beat 和 worker 一起使用\ncelery -A projectname worker -l DEBUG -B -l DEBUG\n\n分开执行\ncelery -A projectname beat -l DEBUG\n\ncelery -A srereport worker -Q reports_queue -l DEBUG\n\n上面的-Q 是配置了队列参数\n有队列时，注意要在代码里加上队列名@shared_task(queue=&#x27;reports_queue&#x27;)def some_task(method_type: str):\n\n根据 task_id 查看任务状态celery -A srereport inspect query_task 03ae7485-a86b-4d6d-aaee-1bda50978a26\n","categories":["知识库","python"],"tags":["celery"]},{"title":"pyenv 使用","url":"/2025/05/14/knows/python/pyenv%E4%BD%BF%E7%94%A8/","content":"pyenv 使用要使用 pyenv 创建一个名为 ai 的新虚拟环境，您可以按照以下步骤操作：\n\n确保已安装 pyenv 和 pyenv-virtualenv首先，确保您已经在系统中安装了 pyenv 和 pyenv-virtualenv。如果还没有安装，可以参考以下步骤进行安装：安装 pyenv\n\n使用 Homebrew 安装（适用于 macOS）brew install pyenv\n\n或者使用官方安装脚本curl https://pyenv.run | bash\n\n安装完成后，根据提示将以下内容添加到您的 shell 配置文件（如 .bashrc, .zshrc）中：\nexport PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init --path)&quot;eval &quot;$(pyenv virtualenv-init -)&quot;\n\n然后，重新加载配置文件：source ~/.bashrc  # 或者 source ~/.zshrc\n\n安装 pyenv-virtualenv如果您使用的是 pyenv 官方安装脚本，pyenv-virtualenv 通常已经包含在内。如果没有，可以通过以下方式安装：\n使用 Homebrew 安装（适用于 macOS）brew install pyenv-virtualenv\n\n或者通过 PyPI 安装\n# 或者通过 PyPI 安装pip install pyenv-virtualenv\n\n\n安装所需的 Python 版本在创建虚拟环境之前，确保您已经安装了所需的 Python 版本。例如，安装 Python 3.10.0：\n\npyenv install 3.10.0\n\n您可以通过以下命令查看可用的 Python 版本：\npyenv install --list`\n\n\n创建虚拟环境使用以下命令创建一个名为 ai 的虚拟环境，并指定 Python 版本（例如 3.10.0）：\n\npyenv virtualenv 3.10.0 ai\n\n如果您希望虚拟环境使用系统默认的 Python 版本，可以省略版本号：\npyenv virtualenv ai\n\n\n激活虚拟环境激活刚刚创建的 ai 虚拟环境：\n\npyenv activate ai\n\n激活后，您的命令提示符通常会显示当前激活的虚拟环境名称 (ai)。 5. 验证虚拟环境您可以通过以下命令验证当前 Python 版本和虚拟环境：\npython --version\n\n输出应类似于：Python 3.10.0\n\n安装项目依赖在虚拟环境中，您可以像平常一样使用 pip 安装所需的包。例如：\n\npip install numpy pandas matplotlib\n\n\n退出虚拟环境当您完成工作并希望退出虚拟环境时，可以使用以下命令：\n\npyenv deactivate\n\n\n列出所有虚拟环境要查看系统中所有已创建的虚拟环境，可以使用：\n\npyenv virtualenvs\n\n\n删除虚拟环境如果您不再需要某个虚拟环境，可以使用以下命令删除它：\n\npyenv uninstall ai\n\npyenv virtualenv-delete sla\n\n常见问题排查pyenv: command not found确保已将 pyenv 的路径添加到您的 shell 配置文件中，并重新加载配置。virtualenv: command not found确保已安装 pyenv-virtualenv 并正确初始化。虚拟环境未激活确认使用 pyenv activate ai 激活虚拟环境，并检查命令提示符是否显示 (ai)。\n通过以上步骤，您应该能够成功使用 pyenv 创建和管理名为 ai 的虚拟环境。如果您遇到任何问题，请随时提问！\nenviron 库有缓存改了环境变量，在本地调试时一定要先清空缓存\nimport environimport osfrom pathlib import Pathenv = environ.Env(DEBUG=(bool, False))env_file = os.path.join(Path(__file__).resolve().parent.parent, &#x27;.env&#x27;)env.read_env(env_file, overwrite=True)  # 使用 overwrite=True 强制重新读取\n","categories":["知识库","python"],"tags":["pyenv"]},{"title":"VTDecoderXPCService是什么进程? 为什么占用 4GB 内存？","url":"/2025/10/22/knows/os/VTDecoderXPCService%E6%98%AF%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B/","content":"VTDecoderXPCService 是 macOS 系统中负责视频解码与处理的核心进程，尤其关联 QuickTime、动态屏保、视频聊天等场景。它通过 XPC 机制独立运行，避免视频处理崩溃影响主系统，但在特定情况下会出现内存占用异常——有用户反馈该进程甚至能占用 6GB 以上内存，导致系统卡顿。\n一、核心功能：视频处理的“幕后工作者”该进程的主要职责包括：\n\n硬件加速解码：调用 macOS 视频工具箱（Video Toolbox）框架，处理 H.264、HEVC 等格式的视频流\n动态内容渲染：支持 macOS Sonoma 新增的动态屏幕保护程序（如慢镜头风景视频）\n第三方应用协作：为微信、浏览器等应用提供视频预览和通话的解码能力，例如微信视频聊天时会触发其后台运行\n\n正常情况下，进程内存占用应在 100MB-500MB 范围内，退出视频相关应用后会自动释放资源。\n二、内存异常的典型场景与成因\n动态屏保的“内存泄漏”macOS Sonoma 引入的动态视频屏保是最常见诱因。用户发现启用后，VTDecoderXPCService 内存占用会持续累积且无法自动回收，即使关闭屏幕保护后仍驻留内存。有推测这是系统为减少硬盘读写而采用的缓存策略，但实际导致资源浪费。\n\n第三方应用的持续调用微信等应用的视频预览功能可能导致进程长期活跃。某用户观察到：“随着微信的登陆，VTDecoderXPCService 就启动起来，偶尔 CPU 占用飙到 30%+”。即使未主动发起视频通话，后台消息中的视频缩略图处理也可能触发内存累积。\n\n系统版本兼容性问题从用户反馈看，内存异常集中出现在 macOS 14（Sonoma）版本，16GB&#x2F;32GB 内存机型同样受影响，说明可能与新系统的视频处理逻辑缺陷相关。\n\n\n三、临时解决方案与优化建议1. 快速缓解：手动终止与限制自启\n强制退出：打开「活动监视器」→ 搜索 VTDecoderXPCService → 点击「退出进程」，内存占用会立即释放（但可能被应用再次唤起）\n禁用动态屏保：系统设置 → 桌面与屏幕保护程序 → 屏幕保护程序 → 选择静态图片或关闭，可彻底避免视频屏保导致的内存问题\n\n2. 长期优化：应用与系统管理\n更新软件：将微信等关联应用升级至最新版本，某案例显示微信更新后视频预览导致的内存泄漏问题显著改善\n系统降级&#x2F;更新：若使用 Sonoma 问题严重，可考虑降级至 macOS Ventura；或等待 Apple 推送修复更新（关注系统偏好设置中的「软件更新」）\n监控后台调用：通过「活动监视器」的「样本」功能，查看该进程被哪些应用触发（如微信、Safari 等），针对性限制应用的视频权限\n\n四、根本解决：等待系统修复从技术本质看，当前内存异常更可能是 macOS Sonoma 的「设计缺陷」而非硬件问题。正如用户吐槽：“你一个动态屏幕本来就是额外的东西，还要占用系统内存资源就太夸张了，关键你要主动回收啊”。建议受影响用户通过 Apple 反馈助手提交问题报告，推动官方修复。\n毕竟在 8GB 内存的 Mac 机型上，一个视频处理进程吃掉 6GB 内存的情况，显然违背了 macOS “高效利用资源”的设计初衷。\n","categories":["知识库"],"tags":["macos"]},{"title":"supervisor配置问题总结","url":"/2025/05/13/knows/python/supervisor%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","content":"问题 1：supervisor 启动 gunicorn 报错：显示\n\ngunicorn FATAL Exited too quickly (process log may have details)但查找进程显示有 gunicorn 进程\n\nps -ef | grep gunicorn\n\n通过 AI 分析：\n\ndaemon &#x3D; True 与 Supervisor 冲突Gunicorn 的 daemon &#x3D; True：会让 Gunicorn 以后台守护进程方式运行（脱离终端），而 Supervisor 本身会管理进程的前台运行。两者同时启用时，Supervisor &gt; 会认为 Gunicorn 已退出（因为 Gunicorn 主进程已退出），导致标记为 FATAL。解决方案：移除 gunicorn 配置文件里的 daemon &#x3D; True，让 Gunicorn 以前台进程方式运行，由 Supervisor 管理。\n\n问题 2：supervisor 启动的项目，还需要指定 pidfile 吗？：显式指定 pidfile,但查看目录并不会生成 pid 文件查 AI：\n\n当你使用 Supervisor 管理应用时，通常不需要再为应用单独配置 pidfile。Supervisor 本身会自动管理所有被监控进程的 PID 文件（进程标识符文件），用于跟踪进程状态（如启动、停止、重启）。以下是详细说明：为什么不需要应用自定义 pidfile？\n\nSupervisor 自动管理 PID 文件Supervisor 会为每个被管理的程序生成一个 .pid 文件，默认路径为：\n\n\n\n/var/run/supervisor/supervisord.pid/tmp/supervisor-&lt;program&gt;.pid\n\n或根据你的配置指定路径。作用：Supervisor 使用 .pid 文件来记录进程的 PID，确保进程状态可追踪。\n\n\n\n应用自定义 pidfile 的潜在问题冲突风险：如果应用（如 Gunicorn）也配置了 pidfile，可能导致：Supervisor 和应用同时写入同一文件，引发冲突。应用退出后，Supervisor 的 .pid 文件可能残留，导致下次启动失败。冗余操作：Supervisor 已经管理了进程生命周期，应用的 pidfile 通常是多余的。\n\n\n参考：CentOS+Django+uWSGI+Celery+Supervisor 配置\n","categories":["知识库","python"],"tags":["supervisor","gunicorn"]},{"title":"神仙道教系类电子书打包下载","url":"/2025/10/23/books/xuxing/mulu/","content":"神仙道教系类电子书打包下载 (4 folders, 70 files, 716.72 MB, 2.36 GB in total.)│ 　万神圭旨·万法秘藏-道家大乘功法仙术秘中之秘.pdf 6.32 MB│ 　丹道薪传-张义尚 2012 版.pdf 43.28 MB│ 　丹道修炼与养生学：武当丹道延寿图说.pdf 49.45 MB│ 　道德经讲义·乐育堂语录.pdf 13.91 MB│ 　道家内丹修炼秘籍.pdf 19.50 MB│ 　道家内功法术研究.pdf 1.05 MB│ 　道家气功精华.pdf 3.11 MB│ 　道家气功南宗丹诀释义.pdf 18.10 MB│ 　道家气功真传.pdf 3.25 MB│ 　道家太极门授功秘录.pdf 6.50 MB│ 　道家养生功.pdf 4.73 MB│ 　道家养生功法集要.pdf 20.87 MB│ 　道家养生秘诀真传.pdf 7.03 MB│ 　道家养生学概要.pdf 8.24 MB│ 　道家養生學概要（蕭天石）.pdf 12.99 MB│ 　道教长生术.pdf 4.21 MB│ 　道教内丹修炼.pdf 37.05 MB│ 　道教内丹养生术（洪丕谟）.pdf 3.20 MB│ 　道教三百题.pdf 11.42 MB│ 　道教养生十日谈.pdf 40.87 MB│ 　道医概说.pdf 15.65 MB│ 　道医讲义.pdf 22.15 MB│ 　道医实用秘本.pdf 440.82 KB│ 　颠倒之术.pdf 6.20 MB│ 　佛家气功玄旨 金刚经金丹直解（纯一子）.pdf 2.92 MB│ 　葛洪研究二集.pdf 17.17 MB│ 　古本周易参同契集注释.pdf 5.30 MB│ 　鸿蒙丹法.pdf 587.30 KB│ 　金丹真传白话浅释-二谢.pdf 9.58 MB│ 　金丹真传九节功夫注疏浅释.pdf 1.02 MB│ 　九层炼心循途录.pdf 4.95 MB│ 　九华金书正文.pdf 750.34 KB│ 　九转还阳法(李康).pdf 426.13 KB│ 　乐育堂语录 道德经精义分类合编.pdf 1.37 MB│ 　龙虎丹道—道教内丹术.pdf 11.11 MB│ 　龙虎山天师府道法研究.pdf 16.45 MB│ 　内丹解码：李西月西派内丹学研究.pdf 23.44 MB│ 　内丹探秘.pdf 5.20 MB│ 　内丹养生功法指要·王沐.pdf 6.66 MB│ 　女丹合编选注（邱小波）.pdf 1.58 MB│ 　女子丹经汇编.pdf 1.81 MB│ 　轻身辟谷术.pdf 5.63 MB│ 　清黄元吉养生静功心法注释.pdf 2.38 MB│ 　全真教清修功法.pdf 4.96 MB│ 　太乙金华秘宗.pdf 4.36 MB│ 　天仙金丹心法.pdf 6.60 MB│ 　天元神丹-指逸斋人.pdf 22.65 MB│ 　文始丹法晋级教材-二谢.pdf 5.95 MB│ 　武功薪传张义尚 2012 版.pdf 36.44 MB│ 　仙家秘传祛病功.pdf 1.15 MB│ 　仙家养生功法.pdf 4.21 MB│ 　仙术秘库.pdf 3.36 MB│ 　仙学详述+田诚阳.pdf 2.19 MB│ 　新编张三丰先生丹道全书（陈全林）.pdf 23.65 MB│ 　性命法诀明指.pdf 7.15 MB│ 　性命法诀全书（千峰老人赵避尘）.pdf 9.13 MB│ 　性命圭旨白话解.pdf 9.34 MB│ 　性命健身秘法.pdf 2.13 MB│ 　性命双修养生延寿法.pdf 3.75 MB│ 　修道入门田诚阳.pdf 9.12 MB│ 　修道养生真诀（黄信阳）.pdf 4.12 MB│ 　养生内丹集要.pdf 9.37 MB│ 　真金丹传.pdf 247.23 KB│ 　震阳子内丹法诀明指.PDF 193.90 KB│ 　中国传统内丹功初级-廖冬晴.pdf 15.81 MB│ 　中国传统内丹功中级-廖冬晴.pdf 6.69 MB│ 　中国道家养气全书.pdf 6.67 MB│ 　中国神仙养生大全.pdf 21.14 MB│ 　中华道家气功.pdf 4.28 MB│ 　中华道家修炼学.pdf 14.28 MB├─ 陈先生内丹诀 (0 folders, 10 files, 148.60 KB, 148.60 KB in total.)│ 　　　九转内丹术-百度百科.txt 23.57 KB│ 　　　陈朴内丹诀注解-云石居士.txt 11.69 KB│ 　　　陈先生内丹诀-正统道藏太平部.txt 18.15 KB│ 　　　陈先生内丹诀.九转金丹秘诀.txt 430 bytes│ 　　　陈先生内丹诀研究.txt 16.82 KB│ 　　　九转内丹术-讲解版.txt 23.23 KB│ 　　　九转内丹术解说版.txt 6.87 KB│ 　　　泥丸先生陈朴传九转金丹秘诀-断句版.txt 15.14 KB│ 　　　泥丸先生陈朴传九转金丹秘诀.txt 15.53 KB│ 　　　陳先生內丹訣.txt 17.17 KB├─ 陈撄宁仙学 (0 folders, 14 files, 302.81 MB, 302.81 MB in total.)│ 　　　·陈撄宁气功论集.pdf 4.51 MB│ 　　　陈撄宁集黄元吉口诀鉤玄录全集.pdf 1.37 MB│ 　　　陈撄宁气功论集.pdf 4.51 MB│ 　　　陈撄宁仙学精要上.胡海牙.pdf 86.38 MB│ 　　　陈撄宁仙学精要下.胡海牙.pdf 82.92 MB│ 　　　丹道仙术入门（胡孚琛）.pdf 68.16 MB│ 　　　道教与仙学 胡孚深.pdf 3.39 MB│ 　　　道教与仙学.胡孚深.pdf 3.39 MB│ 　　　道教与养生（陈撄宁）.pdf 26.95 MB│ 　　　胡海牙的天元丹法函授教材.pdf 354.49 KB│ 　　　仙学解秘.洪建林.pdf 4.26 MB│ 　　　仙学述评.pdf 2.19 MB│ 　　　仙学指南.胡海牙.pdf 14.16 MB│ 　　　学仙必成陈撄宁.pdf 275.86 KB├─ 东方修道文库 (0 folders, 4 files, 115.18 MB, 115.18 MB in total.)│ 　　　[东方修道文库 11 本].全真秘要.pdf 10.67 MB│ 　　　东方修道文库 内炼密诀.pdf 3.79 MB│ 　　　东方修道文库 11 本.rar 98.96 MB│ 　　　涵虚秘旨.pdf 1.77 MB└─ 工具书 (1 folders, 108 files, 1.19 GB, 1.25 GB in total.)　　 │ 　中华仙学养生全书.pdf        10.37 MB 　　│　生死享乐自由—道家及道教的人生理想.pdf 8.74 MB　　 │ 　&#96;玄門日誦早晚功課經注.pdf 3.11 MB　　 │ 　不死的探求抱朴子.pdf 18.82 MB　　 │ 　丹道法诀十二讲.pdf 1.08 MB　　 │ 　丹道法诀十二讲上.pdf 0.99 MB　　 │ 　丹道法诀十二讲下.pdf 821.31 KB　　 │ 　丹道法诀十二讲中.pdf 844.38 KB　　 │ 　丹道修真.chm 1.32 MB　　 │ 　道藏丹经.chm 7.96 MB　　 │ 　道藏分类解题.pdf 12.53 MB　　 │ 　道藏上清大洞真经.chm 2.77 MB　　 │ 　道藏索引：五种版本道藏通检.pdf 16.66 MB　　 │ 　道藏系列 124 种.CHM 7.08 MB　　 │ 　道家和道教思想研究(王明).pdf 12.65 MB　　 │ 　道家经典.exe 4.78 MB　　 │ 　道家十三經.pdf 12.54 MB　　 │ 　道家思想的历史转折(何建明).pdf 16.10 MB　　 │ 　道家文化面面观(刘增惠).pdf 5.34 MB　　 │ 　道家修炼文集.exe 5.74 MB　　 │ 　道家与中国法文化(程维荣).pdf 6.81 MB　　 │ 　道教大辞典（李叔还）.pdf 21.39 MB　　 │ 　道教秘术.pdf 5.11 MB　　 │ 　道教五派丹法精选 第四集.pdf 7.87 MB　　 │ 　道教五派丹法精选 第五集.pdf 9.43 MB　　 │ 　道教五派丹法精选 第二集.pdf 8.77 MB　　 │ 　道教五派丹法精选 第一集.pdf 5.67 MB　　 │ 　道教小辞典.pdf 7.50 MB　　 │ 　道教新论+龚鹏程着.pdf 7.62 MB　　 │ 　道教与中国传统文化.pdf 11.70 MB　　 │ 　道教哲学.pdf 14.05 MB　　 │ 　道经总论.pdf 15.29 MB　　 │ 　道书全集.pdf 32.12 MB　　 │ 　道书十二种.pdf 20.51 MB　　 │ 　道学通论 道家道教丹道.pdf 16.41 MB　　 │ 　方仙道和黄老道的房中术.pdf 922.90 KB　　 │ 　佛道修性养生法.pdf 5.76 MB　　 │ 　古书隐楼藏书.chm 608.69 KB　　 │ 　胡海牙文集.doc 219.00 KB　　 │ 　胡孚琛：魏晋神仙道教.pdf 8.17 MB　　 │ 　淮南子.exe 537.57 KB　　 │ 　黄帝四经与黄老思想.pdf 6.18 MB　　 │ 　黄庭经医疏.pdf 5.33 MB　　 │ 　黄元吉丹法二则.pdf 361.03 KB　　 │ 　慧命经.pdf 1.38 MB　　 │ 　吉冈义丰-道教与佛教.pdf 19.93 MB　　 │ 　金代道教研究：王重阳与马丹阳 (日)峰屋邦夫 2007.pdf 27.75 MB　　 │ 　金丹真传白话浅释.pdf 9.58 MB　　 │ 　金元全真道内丹心性学（张广保）.pdf 5.73 MB　　 │ 　历代丹经汇编,.chm 29.34 MB　　 │ 　历代丹经汇编..CHM 15.55 MB　　 │ 　历代丹经汇编.CHM 15.73 MB　　 │ 　历代丹经汇编—附篇 20140320.CHM 8.58 MB　　 │ 　历代丹经汇编—上 20140320.CHM 23.06 MB　　 │ 　历代真仙体道通鉴.pdf 26.70 MB　　 │ 　吕洞宾全集.pdf 20.02 MB　　 │ 　茅山道教志.pdf 20.48 MB　　 │ 　明清之际道教三教合一思想论.pdf 4.19 MB　　 │ 　南宗仙籍-盛克琦.pdf 1.44 MB　　 │ 　浅谈道教前身—方仙道和黄老道.pdf 153.59 KB　　 │ 　人仙之间—抱朴子与中国文化.pdf 6.09 MB　　 │ 　上阳子金丹大要.exe 1.45 MB　　 │ 　神仙传.pdf 16.32 MB　　 │ 　生命存在与境界超越-道家文化研究丛书.pdf 6.88 MB　　 │ 　生死享乐自由道家及道教的人生理想.pdf 8.74 MB　　 │ 　试述早期全真道与仙学内丹思想之差异.pdf 164.76 KB　　 │ 　太平经.exe 924.78 KB　　 │ 　太上老君清静经图注.exe 2.32 MB　　 │ 　唐宋内丹道教（张广保）.pdf 9.16 MB　　 │ 　王亭之：方术纪异.exe 1.30 MB　　 │ 　武当修真密笈.pdf 8.10 MB　　 │ 　仙学入门.chm 1.11 MB　　 │ 　仙学指归胡海牙整理.doc 353.00 KB　　 │ 　性命法诀明指.exe 430.77 KB　　 │ 　性命圭旨白话解.pdf 17.65 MB　　 │ 　修真法悟(张伯瑞).pdf 707.89 KB　　 │ 　一口气读完道教史.pdf 9.43 MB　　 │ 　隐芝先生文集.exe 642.63 KB　　 │ 　元气论集成.pdf 5.51 MB　　 │ 　云笈七签+(宋)张君房.pdf 31.01 MB　　 │ 　云笈七签+性命圭旨+伍柳仙宗+唱道真言+大成捷要.zip 5.62 MB　　 │ 　云笈七签.exe 2.15 MB　　 │ 　张三丰全集.pdf 4.97 MB　　 │ 　张苏辰内丹养生功论文集.exe 433.19 KB　　 │ 　真丹道与假丹道.pdf 3.71 MB　　 │ 　真诰校注.pdf 25.06 MB　　 │ 　指南针.exe 3.07 MB　　 │ 　中国传统道家养生文化经典.pdf 11.24 MB　　 │ 　中国道教.exe 1.97 MB　　 │ 　中国道教气功养生大全上.pdf 40.64 MB　　 │ 　中国道教气功养生大全下.pdf 35.04 MB　　 │ 　中国方术大辞典古健青.pdf 42.88 MB　　 │ 　中国方术考(修订本)李零.pdf 7.39 MB　　 │ 　中国方术续考 李零.pdf 17.50 MB　　 │ 　中国古代的道士生活.pdf 4.92 MB　　 │ 　中国炼丹术.pdf 4.67 MB　　 │ 　中国炼丹术与丹药.chm 633.87 KB　　 │ 　中国宗教史大纲.pdf 8.30 MB　　 │ 　中华道教大辞典.pdf 194.79 MB　　 │ 　中华道教经纬(徐兆仁).pdf 4.01 MB　　 │ 　中华文化通志 道教志.pdf 9.76 MB　　 │ 　中华仙学养生全书.pdf 5.61 MB　　 │ 　中华仙学养生全书下.pdf 3.35 MB　　 │ 　中华仙学养生全书中.pdf 4.64 MB　　 │ 　钟吕传道集灵宝毕法注译-沉志刚.pdf 41.26 MB　　 │ 　朱越利：道藏分类题解.pdf 7.14 MB　　 │ 　庄子.exe 500.36 KB　　 │ 　黃庭經 中國傳統文化讀本.pdf 1.52 MB　　 └─ 养生修真证道弘典 (0 folders, 9 files, 65.44 MB, 65.44 MB in total.)　　　　　　 10 悟证修真门.pdf 8.27 MB　　　　　　 11 启迷正道门.pdf 5.84 MB　　　　　　 1 人物著述门.pdf 7.78 MB　　　　　　 2 运功导引门.pdf 6.65 MB　　　　　　 3 修心养气门.pdf 7.74 MB　　　　　　 4 功行修持门.pdf 8.57 MB　　　　　　 5 宗派学理门.pdf 8.15 MB　　　　　　 6 教理神道门.pdf 5.68 MB　　　　　　 9 玄机筏喻门.pdf 6.75 MB\n","categories":["道家"]},{"url":"/2025/10/23/books/xuxing/%E9%99%88%E6%92%84%E5%AE%81-%E5%BF%83%E6%81%AF%E7%9B%B8%E4%BE%9D/","content":""}]